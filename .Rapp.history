names(processed.data)
dat[1:5,]
length(dat)
names(dat)
dat[[7]]
getwd()
a <- readRDS("manylabs.data.rds")
a[1:5,]
length(a)
names(a)
# Read in data#
library(foreign)#
library(nloptr)#
dat <- data.frame(read.spss("CleanedDataset.sav"))#
study <- c(study1="Sunk Costs",#
		study2="Gain vs loss framing",#
		study3a="Anchoring - Distance to NYC",#
		study3b="Anchoring - Chicago",#
		study3c="Anchoring - Mt. Everest",#
		study3d="Anchoring - Babies Born",#
		study4="Retrospective gambler fallacy",#
		study5="Low vs high category scales",#
		study6="Norm of reciprocity",#
		study7="Allowed/Forbidden",#
		study8="Quote Attribution",#
		study9="Flag Priming",#
		study10="Currency Priming",#
		study11="Imagined contact",#
		study12a="Sex differences in implicit math attitudes")#,#
		###study12b="Relations between impl. and expl. math attitudes")#
#
var.type <- c("O", "B", "C", "C", "C", "C", "C",#
				"B", "B", "B", "O", "C", "C", "C", "C")#
#
# Organize data#
YY <- TT <- matrix(NA, nrow(dat), length(study))#
OO <- as.matrix( dat[,c("sunkcostorder", "diseaseforder", "anchorinorder", "gamblerforder",#
						"scalesorder", "reciprocorder", "allowedforder", "quoteorder",#
						"flagprimorder", "moneypriorder", "imaginedorder", "iatorder" )] )#
condition2.name <- condition1.name <- rep(NA, length(study))#
lab.name <- dat$sample#
#
# Create lab information#
ulab <- sort(unique(as.character(lab.name)))#
online <- nonUS <- rep(0,length(ulab))#
online[c(5,8,9,13,15,18,24,27,30)] <- 1#
nonUS[c(2,3,6,9,10,11,14,23,24,28,30)] <- 1#
lab.info <- data.frame(Lab=ulab, Online=online, NonUS=nonUS)#
#
# Code dependent measures#
i <- 1#
condition2.name[i] <- "paid"#
condition1.name[i] <- "free"#
YY[,i] <- dat$sunkDV#
TT[,i] <- 1*(dat$sunkgroup==condition2.name[i])#
#
i <- 2#
condition2.name[i] <- "People will die"#
condition1.name[i] <- "People will be saved"#
YY[,i] <- 1*(dat$gainlossDV=="chose program with probability outcome")#
TT[,i] <- 1*(dat$gainlossgroup==condition2.name[i])#
#
i <- 3#
condition2.name[i] <- "highanchor"#
condition1.name[i] <- "lowanchor"#
YY[,i] <- dat$anchoring1#
TT[,i] <- 1*(dat$anch1group==condition2.name[i])#
#
i <- 4#
condition2.name[i] <- "highanchor"#
condition1.name[i] <- "lowanchor"#
YY[,i] <- dat$anchoring2#
TT[,i] <- 1*(dat$anch2group==condition2.name[i])#
#
i <- 5#
condition2.name[i] <- "highanchor"#
condition1.name[i] <- "lowanchor"#
YY[,i] <- dat$anchoring3#
TT[,i] <- 1*(dat$anch3group==condition2.name[i])#
#
i <- 6#
condition2.name[i] <- "highanchor"#
condition1.name[i] <- "lowanchor"#
YY[,i] <- dat$anchoring4#
TT[,i] <- 1*(dat$anch4group==condition2.name[i])#
#
i <- 7#
condition2.name[i] <- "three6"#
condition1.name[i] <- "two6"#
YY[,i] <- dat$gambfalDV^2#
TT[,i] <- 1*(dat$gambfalgroup==condition2.name[i])#
#
i <- 8#
condition2.name[i] <- "high category scale"#
condition1.name[i] <- "low category scale"#
YY[,i] <- 1*(dat$scales=="more than 2 1/2 hrs")#
TT[,i] <- 1*(dat$scalesgroup==condition2.name[i])#
#
i <- 9#
condition2.name[i] <- "Asked second"#
condition1.name[i] <- "Asked first"#
YY[,i] <- 1*(dat$reciprocityus=="yes")#
TT[,i] <- 1*(dat$reciprocitygroup==condition2.name[i])#
#
i <- 10#
condition2.name[i] <- "allowed"#
condition1.name[i] <- "forbidden"#
YY[,i] <- 1*( (dat$allowedforbiddenGroup==condition2.name[i] & dat$allowedforbidden=="NO") | #
              (dat$allowedforbiddenGroup==condition1.name[i] & dat$allowedforbidden=="YES") )#
TT[,i] <- 1*(dat$allowedforbiddenGroup==condition2.name[i])#
#
i <- 11#
condition2.name[i] <- "liked source"#
condition1.name[i] <- "disliked source"#
YY[,i] <- dat$quote#
TT[,i] <- 1*(dat$quoteGroup==condition2.name[i])#
#
i <- 12#
condition2.name[i] <- "flag prime"#
condition1.name[i] <- "no prime"#
YY[,i] <- dat$flagdv#
TT[dat$flagGroup==condition2.name[i],i] <- 1#
TT[dat$flagGroup==condition1.name[i],i] <- 0#
#
i <- 13#
condition2.name[i] <- "Money priming group"#
condition1.name[i] <- "Control group"#
YY[,i] <- dat$Sysjust#
TT[,i] <- 1*(dat$MoneyGroup==condition2.name[i])#
#
i <- 14#
condition2.name[i] <- "Contact group"#
condition1.name[i] <- "Control group"#
YY[,i] <- dat$Imagineddv#
TT[,i] <- 1*(dat$ContactGroup==condition2.name[i])#
#
i <- 15#
condition2.name[i] <- "female"#
condition1.name[i] <- "male"#
YY[,i] <- dat$d_art#
TT[dat$partgender==condition2.name[i],i] <- 1#
TT[dat$partgender==condition1.name[i],i] <- 0#
#
# Sign check#
for(i in 1:ncol(YY)){ if(diff(t.test(YY[,i]~TT[,i])$estimate) < 0){ print(study[i]) } }#
#
# Set YY and TT to NA if either is NA#
colSums(is.na(YY))#
colSums(is.na(TT))#
table(is.na(YY), is.na(TT))#
colSums(is.na(TT) & !is.na(YY))#
sel <- is.na(YY) | is.na(TT)#
YY[sel] <- TT[sel] <- NA#
#
# Apply two-parameter Box-Cox transformation to continuous data#
gmean <- function(x, na.rm=TRUE){ exp(mean(log(x), na.rm=na.rm)) }#
box.cox <- function(y, lambda=c(0,0)){#
	if(lambda[1]==0){ log(y + lambda[2])#
	}else{ ((y + lambda[2])^lambda[1] - 1) / lambda[1] }#
}#
nll.bc <- function(lambda, y, X){#
	tmpy <- box.cox(y, lambda)#
	tmpz <- tmpy / gmean(y+lambda[2])^(lambda[1]-1)#
	tmpm <- lm(tmpz ~ X - 1)	#
	return(-as.numeric(logLik(tmpm)))#
}#
nll.bc1 <- function(lambda1,lambda2=0,y,X){ nll.bc(c(lambda1,lambda2),y,X) }#
nll.bc2 <- function(lambda2,lambda1=1,y,X){ nll.bc(c(lambda1,lambda2),y,X) }#
res.bc <- function(lambda, y, X){#
	lambda1 <- lambda[1]#
	lambda2 <- lambda[2] #
	tmpy <- box.cox(y, c(lambda1,lambda2))#
	tmpm <- lm(tmpy ~ X - 1)#
	return(tmpm$residuals)#
}#
#
YY0 <- YY#
for(i in 1:ncol(YY)){#
	if(var.type[i]=="C"){#
		sel <- !is.na(YY[,i])		#
		tmp.dat <- data.frame(yy=YY[sel,i], ll=as.character(lab.name[sel]), tt=factor(TT[sel,i]))#
		tmp.model <- lm(yy ~ ll*tt - ll - tt - 1, data=tmp.dat)#
		yy <- tmp.dat$yy#
		XX <- model.matrix(tmp.model)#
		lambda2.null <- ifelse(all(yy>0), 0, -min(yy)+1E-04)#
		lbound <- c(-3, -min(yy)+1E-04)#
		ubound <- c(3, 5*max(yy))#
		oo <- bobyqa(c(1,lambda2.null), nll.bc, y=yy, X=XX, lower=lbound, upper=ubound)			#
		YY[sel,i] <- box.cox(yy, oo$par)#
		print(i)#
	}#
}#
#
# Sign alignment (also relabel conditions to maintain the condition2 > condition1 convention)#
RR <- cor(YY, use="pair")#
data.frame(study, eigen(RR)$vectors[,1])#
tmp0 <- tmp1 <- YY#
tmp0[TT==0] <- NA#
tmp1[TT==1] <- NA#
tmp.idx <- rep(1:ncol(YY), each=2) + rep(c(0,ncol(YY)), ncol(YY))#
tmp2 <- cbind(tmp0,tmp1)[,tmp.idx]#
RRR <- cor(tmp2, use="pair")#
RRR[is.na(RRR)] <- 0#
data.frame(paste0(rep(study,each=2), "*", rep(1:2,ncol(YY))),#
	  	   eigen(RRR)$vectors[,1], rep(eigen(RR)$vectors[,1], each=2))#
#
reverse.code <- c(0,1,  1,1,1,1,  0,0,1,0,1,0,0,1,1)#
table(eigen(RR)$vectors[,1] < 0, reverse.code)#
#
TT0 <- TT#
condition2.name0 <- condition2.name#
condition1.name0 <- condition1.name#
for(i in which(reverse.code==1)){ #
	TT[,i] <- 1 - TT[,i]#
	condition2.name[i] <- condition1.name0[i]#
	condition1.name[i] <- condition2.name0[i]#
#
	if(var.type[i]=="B"){ YY[,i] <- 1 - YY[,i] }#
	if(var.type[i]=="C"){ YY[,i] <- -YY[,i] }#
	if(var.type[i]=="O"){ YY[,i] <- (max(YY[,i], na.rm=TRUE) + 1) - YY[,i] }#
}#
#
# Write output#
study.info <- data.frame(Study=study, VarType=var.type, Reverse=reverse.code,#
	Condition1=condition1.name, Condition2=condition2.name)#
processed.data <- list(YY=YY, TT=TT, lab.id=lab.name,#
	study.info=study.info, lab.info=lab.info, YY0=YY0,#
	political.ideology=dat$politicalid)#
saveRDS(processed.data, "manylabs.data.rds")
length(processed.data)
processed.data[[7]]
names(processed.data)
table(processed.data[[7]], as.numeric(process.data[[7]]))
table(processed.data[[7]], as.numeric(processed.data[[7]]))
# Load packages and read in data#
setwd("/Users/blakemcshane/Dropbox/Dropbox Research/pcurve/SPML/Blake/manylabs.v3/clean/_jasa_pseudo_reproducibility/ideology")#
library(reshape2)#
library(ggplot2)#
#options(mc.cores = parallel::detectCores())#
#rstan_options(auto_write = TRUE)#
library(abind)#
#
processed.data <- readRDS("manylabs.data.rds")#
YY <- processed.data$YY#
TT <- processed.data$TT#
lab <- processed.data$lab.id#
study <- processed.data$study.info[,1]#
var.type <- processed.data$study.info[,2]#
#
# Prepare data for Stan#
dat <- melt(YY)#
colnames(dat)[1:2] <- c("SubjectID","EffectID")#
dat$Treatment <- melt(TT)$value + 1#
dat$Lab <- lab#
dat$LabID <- as.numeric(dat$Lab)#
dat$VarType <- var.type[dat$EffectID]#
dat <- dat[!is.na(dat$value),]#
#
# Scalars for stan#
nCond <- 2		# All DVs have two conditions#
nCatO <- 9		# Both ordinal DVs are 1:9#
nLab <- max(dat$LabID)#
nSubj <- max(dat$SubjectID)#
nRowC <- sum(dat$VarType=="C")#
nRowB <- sum(dat$VarType=="B")#
nRowO <- sum(dat$VarType=="O")#
nDepvar <- length(unique(dat$EffectID))#
nDepvarC <- length(unique(dat$EffectID[dat$VarType=="C"]))#
nDepvarB <- length(unique(dat$EffectID[dat$VarType=="B"]))#
nDepvarO <- length(unique(dat$EffectID[dat$VarType=="O"]))#
#
# Continuous for stan#
datC <- dat[dat$VarType=="C",]#
datC$EffectID2 <- as.numeric(as.factor(datC$EffectID))#
s.pool <- rep(NA, max(datC$EffectID2))#
for(i in 1:length(s.pool)){#
	sel <- datC$EffectID2==i#
	tmpv <- by(datC$value[sel], list(datC$Lab[sel], datC$Treatment[sel]), var)#
	tmpn <- by(datC$value[sel], list(datC$Lab[sel], datC$Treatment[sel]), length)#
	s.pool[i] <- sqrt( sum((tmpn-1)*tmpv, na.rm=TRUE) / sum(tmpn-1, na.rm=TRUE) )#
}#
#
# Binary for stan#
datB <- dat[dat$VarType=="B",]#
datB$EffectID2 <- as.numeric(as.factor(datB$EffectID)) + nDepvarC#
#
# Ordinal for stan#
datO <- dat[dat$VarType=="O",]#
datO$EffectID2 <- as.numeric(as.factor(datO$EffectID)) + nDepvarC + nDepvarB#
#
study.orig <- study#
var.type.orig <- var.type#
study <- study[c(unique(datC$EffectID), unique(datB$EffectID), unique(datO$EffectID))]#
var.type <- var.type[c(unique(datC$EffectID), unique(datB$EffectID), unique(datO$EffectID))]#
Anch_ind <- 1*grepl("Anchoring", study)#
nAnch <- sum(Anch_ind)#
study.orig <- study#
study <- c(#
	"Anchoring:\nDistance from SF to NYC",#
	"Anchoring:\nPopulation of Chicago",#
	"Anchoring:\nHeight of Mount Everest",#
	"Anchoring:\nUS Babies Born Per Day",#
	"Retrospective\nGambler Fallacy",#
	"Flag Priming",#
	"Currency Priming",#
	"Imagined Contact",#
	"Sex Differences in\nImplicit Math Attitudes",#
	"Gain vs. Loss Framing",#
	"Low vs. High\nCategory Scales",#
	"Norm of Reciprocity",#
	"Allowed vs. Forbidden",#
	"Sunk Costs",#
	"Quote Attribution"#
	)#
study.order.alphabetical <- c(sort(study[-(1:4)]), sort(study[1:4]))#
#
study.order <- NA			# WHEN RUNNING SCRIPT GET STUDY ORDER FROM NO.IDEOLOGY SCRIPT#
#
study.order <- c("Gain vs. Loss Framing", "Retrospective\nGambler Fallacy", #
"Sex Differences in\nImplicit Math Attitudes", "Sunk Costs", "Quote Attribution", #
"Low vs. High\nCategory Scales", "Allowed vs. Forbidden", "Currency Priming", "Imagined Contact",#
"Norm of Reciprocity", "Flag Priming", "Anchoring:\nDistance from SF to NYC", #
"Anchoring:\nUS Babies Born Per Day", "Anchoring:\nPopulation of Chicago", #
"Anchoring:\nHeight of Mount Everest")#
#
load("postX.processed.init.noideology.Rdata")#
n.iter.post <- dim(aa4)[[1]]#
n.chains <- dim(aa4)[[2]]#
fun.alpha <- function(y,alpha=0.05){ #
	out <- quantile(y,probs=c(alpha/2,0.5,1-alpha/2))#
	names(out) <- c("ymin","y","ymax")#
	out#
}#
f95 <- function(y){ fun.alpha(y,0.05) }#
f50 <- function(y){ fun.alpha(y,0.50) }#
ppp <- c(0.025, 0.25,   0.50,   0.75, 0.975)#
qqq <- qnorm(ppp)#
#
cc <- matrix(0, nDepvar, nCond*nDepvar)#
for(i in 1:nDepvar){#
	tmpj <- (i-1)*nCond + 1#
	cc[i,tmpj:(tmpj+nCond-1)] <- c(-1,1)#
}#
modk <- function(x,k){ tmp <- x%%k; ifelse(tmp==0,k,tmp) }#
cond <- c("Condition 1", "Condition 2")#
xx <- seq(-3, 3, length=101)#
idxO <- seq(1, nDepvarO*(nCatO-1), by=nDepvarO)#
tmpi <- aa4[,,grepl("alpha_int_cd\\[", dimnames(aa4)[[3]])]#
tmpi.cut <- aa4[,,grepl("cutpoints_dO", dimnames(aa4)[[3]])]#
tmpi[,,27] <- apply(tmpi.cut[,,idxO], 1:2, function(x){sum(x)/nCatO}) - tmpi[,,28]/2#
tmpi[,,28] <- apply(tmpi.cut[,,idxO], 1:2, function(x){sum(x)/nCatO}) + tmpi[,,28]/2#
tmpi[,,29] <- apply(tmpi.cut[,,idxO+1], 1:2, function(x){sum(x)/nCatO}) - tmpi[,,30]/2#
tmpi[,,30] <- apply(tmpi.cut[,,idxO+1], 1:2, function(x){sum(x)/nCatO}) + tmpi[,,30]/2#
tmps <- aa4[,,grepl("alpha_XX_cd", dimnames(aa4)[[3]])]#
tmpxa <- array(NA, c(dim(tmpi), length(xx)))#
for(i in 1:length(xx)){#
	tmpxa[,,,i] <- tmpi + tmps*xx[i]	#
}#
for(i in seq(1,nCond*nDepvar,by=nCond)){#
	tmpxa[,,i:(i+nCond-1),] <- tmpxa[,,i:(i+nCond-1),] - mean( tmpxa[,,i:(i+nCond-1),] )#
}#
tmp3 <- melt(apply(tmpxa, 3:4, median))#
tmp3$Effect <- study[ceiling(tmp3$Var1/2)]#
tmp3$Effect <- factor(tmp3$Effect, levels=study.order)#
tmp3$Condition <- paste("Condition", -(tmp3$Var1%%2) + 2)#
tmp3$xx <- xx[tmp3$Var2] + 4#
tmp3$ym <- melt(apply(tmpxa, 3:4, quantile, probs=0.025))$value#
tmp3$yM <- melt(apply(tmpxa, 3:4, quantile, probs=0.975))$value#
tmp4 <- apply(cbind(by(tmp3$ym, tmp3$Effect, min), by(tmp3$yM, tmp3$Effect, max)), #
					1, function(x){max(abs(x))})#
tmp4 <- data.frame(Effect=rep(names(tmp4),2), xx=mean(xx)+4, value=c(tmp4,-tmp4))#
tmp4$Effect <- factor(tmp4$Effect, levels=study.order)#
alphaX <- ggplot(tmp3, aes(x=xx,y=value,col=Condition)) + facet_wrap(~Effect, scales="free_y") +  #
	 geom_line() + #
	 geom_line(aes(y=ym),linetype=2,size=0.25) +#
	 geom_line(aes(y=yM),linetype=2,size=0.25) +#
	 scale_x_continuous("Political Ideology", breaks=c(1,3,5,7)) +#
	 ylab(expression(paste("Value (", sigma[d], ")"))) + theme(legend.position="bottom") +#
	 geom_point(data=tmp4,col=NA)
getwd()
setwd("/Users/blakemcshane/Desktop")
ggsave("graph_paper_mlp5_init.pdf", plot=alphaX, device=cairo_pdf, width=4/3*6.5, height=4/3*7.25)
# Load packages and read in data#
setwd("/Users/blakemcshane/Dropbox/Dropbox Research/pcurve/SPML/Blake/manylabs.v3/clean/_jasa_pseudo_reproducibility/ideology")#
library(reshape2)#
library(ggplot2)#
#options(mc.cores = parallel::detectCores())#
#rstan_options(auto_write = TRUE)#
library(abind)#
#
processed.data <- readRDS("manylabs.data.rds")#
YY <- processed.data$YY#
TT <- processed.data$TT#
lab <- processed.data$lab.id#
study <- processed.data$study.info[,1]#
var.type <- processed.data$study.info[,2]#
#
# Prepare data for Stan#
dat <- melt(YY)#
colnames(dat)[1:2] <- c("SubjectID","EffectID")#
dat$Treatment <- melt(TT)$value + 1#
dat$Lab <- lab#
dat$LabID <- as.numeric(dat$Lab)#
dat$VarType <- var.type[dat$EffectID]#
dat <- dat[!is.na(dat$value),]#
#
# Scalars for stan#
nCond <- 2		# All DVs have two conditions#
nCatO <- 9		# Both ordinal DVs are 1:9#
nLab <- max(dat$LabID)#
nSubj <- max(dat$SubjectID)#
nRowC <- sum(dat$VarType=="C")#
nRowB <- sum(dat$VarType=="B")#
nRowO <- sum(dat$VarType=="O")#
nDepvar <- length(unique(dat$EffectID))#
nDepvarC <- length(unique(dat$EffectID[dat$VarType=="C"]))#
nDepvarB <- length(unique(dat$EffectID[dat$VarType=="B"]))#
nDepvarO <- length(unique(dat$EffectID[dat$VarType=="O"]))#
#
# Continuous for stan#
datC <- dat[dat$VarType=="C",]#
datC$EffectID2 <- as.numeric(as.factor(datC$EffectID))#
s.pool <- rep(NA, max(datC$EffectID2))#
for(i in 1:length(s.pool)){#
	sel <- datC$EffectID2==i#
	tmpv <- by(datC$value[sel], list(datC$Lab[sel], datC$Treatment[sel]), var)#
	tmpn <- by(datC$value[sel], list(datC$Lab[sel], datC$Treatment[sel]), length)#
	s.pool[i] <- sqrt( sum((tmpn-1)*tmpv, na.rm=TRUE) / sum(tmpn-1, na.rm=TRUE) )#
}#
#
# Binary for stan#
datB <- dat[dat$VarType=="B",]#
datB$EffectID2 <- as.numeric(as.factor(datB$EffectID)) + nDepvarC#
#
# Ordinal for stan#
datO <- dat[dat$VarType=="O",]#
datO$EffectID2 <- as.numeric(as.factor(datO$EffectID)) + nDepvarC + nDepvarB#
#
study.orig <- study#
var.type.orig <- var.type#
study <- study[c(unique(datC$EffectID), unique(datB$EffectID), unique(datO$EffectID))]#
var.type <- var.type[c(unique(datC$EffectID), unique(datB$EffectID), unique(datO$EffectID))]#
Anch_ind <- 1*grepl("Anchoring", study)#
nAnch <- sum(Anch_ind)#
study.orig <- study#
study <- c(#
	"Anchoring:\nDistance from SF to NYC",#
	"Anchoring:\nPopulation of Chicago",#
	"Anchoring:\nHeight of Mount Everest",#
	"Anchoring:\nUS Babies Born Per Day",#
	"Retrospective\nGambler Fallacy",#
	"Flag Priming",#
	"Currency Priming",#
	"Imagined Contact",#
	"Sex Differences in\nImplicit Math Attitudes",#
	"Gain vs. Loss Framing",#
	"Low vs. High\nCategory Scales",#
	"Norm of Reciprocity",#
	"Allowed vs. Forbidden",#
	"Sunk Costs",#
	"Quote Attribution"#
	)#
study.order.alphabetical <- c(sort(study[-(1:4)]), sort(study[1:4]))#
#
study.order <- NA			# WHEN RUNNING SCRIPT GET STUDY ORDER FROM NO.IDEOLOGY SCRIPT#
#
study.order <- c("Gain vs. Loss Framing", "Retrospective\nGambler Fallacy", #
"Sex Differences in\nImplicit Math Attitudes", "Sunk Costs", "Quote Attribution", #
"Low vs. High\nCategory Scales", "Allowed vs. Forbidden", "Currency Priming", "Imagined Contact",#
"Norm of Reciprocity", "Flag Priming", "Anchoring:\nDistance from SF to NYC", #
"Anchoring:\nUS Babies Born Per Day", "Anchoring:\nPopulation of Chicago", #
"Anchoring:\nHeight of Mount Everest")#
#
load("postX.processed.Rdata")#
n.iter.post <- dim(aa4)[[1]]#
n.chains <- dim(aa4)[[2]]
fun.alpha <- function(y,alpha=0.05){ #
	out <- quantile(y,probs=c(alpha/2,0.5,1-alpha/2))#
	names(out) <- c("ymin","y","ymax")#
	out#
}#
f95 <- function(y){ fun.alpha(y,0.05) }#
f50 <- function(y){ fun.alpha(y,0.50) }#
ppp <- c(0.025, 0.25,   0.50,   0.75, 0.975)#
qqq <- qnorm(ppp)#
#
cc <- matrix(0, nDepvar, nCond*nDepvar)#
for(i in 1:nDepvar){#
	tmpj <- (i-1)*nCond + 1#
	cc[i,tmpj:(tmpj+nCond-1)] <- c(-1,1)#
}#
modk <- function(x,k){ tmp <- x%%k; ifelse(tmp==0,k,tmp) }#
cond <- c("Condition 1", "Condition 2")#
xx <- seq(-3, 3, length=101)#
idxO <- seq(1, nDepvarO*(nCatO-1), by=nDepvarO)#
tmpi <- aa4[,,grepl("alpha_int_cd\\[", dimnames(aa4)[[3]])]#
tmpi.cut <- aa4[,,grepl("cutpoints_dO", dimnames(aa4)[[3]])]#
tmpi[,,27] <- apply(tmpi.cut[,,idxO], 1:2, function(x){sum(x)/nCatO}) - tmpi[,,28]/2#
tmpi[,,28] <- apply(tmpi.cut[,,idxO], 1:2, function(x){sum(x)/nCatO}) + tmpi[,,28]/2#
tmpi[,,29] <- apply(tmpi.cut[,,idxO+1], 1:2, function(x){sum(x)/nCatO}) - tmpi[,,30]/2#
tmpi[,,30] <- apply(tmpi.cut[,,idxO+1], 1:2, function(x){sum(x)/nCatO}) + tmpi[,,30]/2#
tmps <- aa4[,,grepl("alpha_XX_cd", dimnames(aa4)[[3]])]#
tmpxa <- array(NA, c(dim(tmpi), length(xx)))#
for(i in 1:length(xx)){#
	tmpxa[,,,i] <- tmpi + tmps*xx[i]	#
}#
for(i in seq(1,nCond*nDepvar,by=nCond)){#
	tmpxa[,,i:(i+nCond-1),] <- tmpxa[,,i:(i+nCond-1),] - mean( tmpxa[,,i:(i+nCond-1),] )#
}#
tmp3 <- melt(apply(tmpxa, 3:4, median))#
tmp3$Effect <- study[ceiling(tmp3$Var1/2)]#
tmp3$Effect <- factor(tmp3$Effect, levels=study.order)#
tmp3$Condition <- paste("Condition", -(tmp3$Var1%%2) + 2)#
tmp3$xx <- xx[tmp3$Var2] + 4#
tmp3$ym <- melt(apply(tmpxa, 3:4, quantile, probs=0.025))$value#
tmp3$yM <- melt(apply(tmpxa, 3:4, quantile, probs=0.975))$value#
tmp4 <- apply(cbind(by(tmp3$ym, tmp3$Effect, min), by(tmp3$yM, tmp3$Effect, max)), #
					1, function(x){max(abs(x))})#
tmp4 <- data.frame(Effect=rep(names(tmp4),2), xx=mean(xx)+4, value=c(tmp4,-tmp4))#
tmp4$Effect <- factor(tmp4$Effect, levels=study.order)#
alphaX <- ggplot(tmp3, aes(x=xx,y=value,col=Condition)) + facet_wrap(~Effect, scales="free_y") +  #
	 geom_line() + #
	 geom_line(aes(y=ym),linetype=2,size=0.25) +#
	 geom_line(aes(y=yM),linetype=2,size=0.25) +#
	 scale_x_continuous("Political Ideology", breaks=c(1,3,5,7)) +#
	 ylab(expression(paste("Value (", sigma[d], ")"))) + theme(legend.position="bottom") +#
	 geom_point(data=tmp4,col=NA)
getwd()
setwd("/Users/blakemcshane/Desktop)
setwd("/Users/blakemcshane/Desktop")
ggsave("graph_paper_mlp5.pdf", plot=alphaX, device=cairo_pdf, width=4/3*6.5, height=4/3*7.25)
~/Desktop/mlp_reproducibility2/posterior1.init.rds
a <- readRDS("~/Desktop/mlp_reproducibility2/posterior1.init.rds")
b <- readRDS("~/Desktop/mlp_reproducibility/posterior1.init.rds")
range(a-b)
length(a)
length(b)
for(i in 1:20){ print(range(a[[1]]-b[[1]])) }
a <- readRDS("~/Desktop/mlp_reproducibility2/posterior1.rds")
b <- readRDS("~/Desktop/mlp_reproducibility/posterior1.rds")
b <- readRDS("~/Desktop/mlp_reproducibility_corr/posterior1.rds")
dim(a)
dim(b)
dd <- a-b
dim(dd)
ddd <- apply(dd, 1:2, function(x){max(abs(x))})
dim(ddd)
ddd <- apply(dd, 3, function(x){max(abs(x))})
dim(ddd)
hist(ddd)
range(ddd)
rug(ddd)
mean(ddd==0)
mean(ddd < 1E-08)
hist(log(ddd))
ddd[1:100]
ddd[ddd==0]
library(tidyverse)#
dat <- read.csv("/Users/blakemcshane/Documents/Academic Research/MetaAnalysis/RRR/fischer_att_snarc/analysis/RRR_data_raw.csv", header=TRUE)
dat[1:5,]
dim(dat)
length(unique(dat[,1]))
968800/1211
# Read in data#
library(foreign)#
library(nloptr)#
dat <- data.frame(read.spss("CleanedDataset.sav"))#
study <- c(study1="Sunk Costs",#
		study2="Gain vs loss framing",#
		study3a="Anchoring - Distance to NYC",#
		study3b="Anchoring - Chicago",#
		study3c="Anchoring - Mt. Everest",#
		study3d="Anchoring - Babies Born",#
		study4="Retrospective gambler fallacy",#
		study5="Low vs high category scales",#
		study6="Norm of reciprocity",#
		study7="Allowed/Forbidden",#
		study8="Quote Attribution",#
		study9="Flag Priming",#
		study10="Currency Priming",#
		study11="Imagined contact",#
		study12a="Sex differences in implicit math attitudes")#,#
		###study12b="Relations between impl. and expl. math attitudes")#
#
var.type <- c("O", "B", "C", "C", "C", "C", "C",#
				"B", "B", "B", "O", "C", "C", "C", "C")#
#
# Organize data#
YY <- TT <- matrix(NA, nrow(dat), length(study))#
OO <- as.matrix( dat[,c("sunkcostorder", "diseaseforder", "anchorinorder", "gamblerforder",#
						"scalesorder", "reciprocorder", "allowedforder", "quoteorder",#
						"flagprimorder", "moneypriorder", "imaginedorder", "iatorder" )] )#
condition2.name <- condition1.name <- rep(NA, length(study))#
lab.name <- dat$sample#
#
# Create lab information#
ulab <- sort(unique(as.character(lab.name)))#
online <- nonUS <- rep(0,length(ulab))#
online[c(5,8,9,13,15,18,24,27,30)] <- 1#
nonUS[c(2,3,6,9,10,11,14,23,24,28,30)] <- 1#
lab.info <- data.frame(Lab=ulab, Online=online, NonUS=nonUS)
getwd()
a <- readRDS("manylabs.data.rds")
b <- readRDS("manylabs.data.ulf.rds")
for(i in 1:length(a)){ print(mean(a[[i]]  ==  b[[i]])) }
for(i in 1:length(a)){ print(mean(a[[i]]  ==  b[[i]], na.rm=TRUE)) }
for(i in 1:length(a)){ print(mean(is.na(a[[i]])  ==  is.na(b[[i]]))) }
tmp <- a[[1]] - b[[1]]
hist(tmp)
range(tmp, na.rm=TRUE)
processed.data <- readRDS("mlp_reproducibility_corr/manylabs.data.rds")
YY <- processed.data[[1]]
TT <- processed.data[[2]]
for(i in 1:ncol(YY)){ if(diff(t.test(YY[,i]~TT[,i])$estimate) < 0){ print(study[i]) } }
for(i in 1:ncol(YY)){ if(diff(t.test(YY[,i]~TT[,i])$estimate) < 0){ print(i) } }
t.test(YY[,i]~TT[,i])
for(i in 1:ncol(YY)){ print(t.test(YY[,i]~TT[,i])$estimate) } }
for(i in 1:ncol(YY)){ print(t.test(YY[,i]~TT[,i])$estimate) }
dim(YY)
a <- readRDS("posterior1.init.rds")
b <- readRDS("posterior1.init.rds")
length(a)
length(b)
a[[1]]
b[[1]]
for(i in 1:20){ print(range(a[[i]]-b[[i]])) }
for(i in 1:20){ print(cor(a[[i]], b[[i]])) }
]
for(i in 1:20){ print(cor(as.numeric(a[[i]]), as.numeric(b[[i]]))) }
for(i in 10:10){ print(cor(as.numeric(a[[i]]), as.numeric(b[[i]]))) }
names(a)[10]
idx <- 1; plot(as.numeric(a[[i]]), as.numeric(b[[i]]))
idx <- 1; plot(as.numeric(a[[idx]), as.numeric(b[[idx]]))
idx <- 1; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]))
idx <- 2; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]))
idx <- 2; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx])
idx <- 3; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx])
idx <- 3; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col-2)
idx <- 3; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 1; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 2; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 3; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 4; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 5; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 6; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 7; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 8; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 9; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 10; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 11; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 12; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 13; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 14; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 15; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 16; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 17; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 18; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 19; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 20; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
idx <- 21; plot(as.numeric(a[[idx]]), as.numeric(b[[idx]]), main=names(a)[idx]); abline(0,1,col=2)
load('~/Desktop/results_022419.Rdata')
ls()
fit.stats
estimates
dat1 <- read.csv("data_4condv2_UPDATED_02.25.22.csv", header=TRUE)
dat2 <- NULL
eammcs_only <- FALSE
dim(dat1)
dat1[1:5,]
library(metafor)#
source("aux.general.D.R")#
source("aux.reml.aux.blup.optim.option.R")#
results <- messages <- list()#
#
date()#
#
# Error checking I:#
if(is.null(dat1)){ return("Error: No main input data provided.") }#
if(any(is.na(dat1))){ return("Error: No NAs allowed in main input data.") }#
if(ncol(dat1) < 4){ return("Error: Main input data has less than four columns. It must have at minimum four columns.") }#
if(!is.null(dat2)){#
	if(any(is.na(dat2))){ return("Error: No NAs allowed in error variance covariance matrix.") }#
	if(nrow(dat1)!=nrow(dat2)){ return("Error: Main input data and error variance covariance matrix have a different number of rows.") }#
	if(nrow(dat2)!=ncol(dat2)){ return("Error: The error variance covariance matrix must be square.") }#
	Sigma.y <- as.matrix(dat2)#
	M <- max(abs( Sigma.y - t(Sigma.y) ))#
	if(M > 1E-08){ return("Error: The error variance covariance matrix must be symmetric.") }#
	m <- min(eigen(Sigma.y,only.values=TRUE)$values)#
	if(m < 1E-08){ return("Error: The error variance covariance matrix must be positive definite.") }#
	M <- max(abs( diag(Sigma.y) - dat1$v ))#
	if(M > 1E-08){ messages[[length(messages)+1]] <- paste0("Note: The diagonal of the error ",   #
		"variance covariance matrix and the v column of the main input data do not match. As always ",#
		"when an error variance covariance matrix is provided, using the error variance covariance ",#
		"matrix and ignoring the v column of the main input data.") }#
}else{#
	Sigma.y <- diag(dat1$v)#
}#
#
# Error checking II:#
idx1 <- which(colnames(dat1)=="ConditionDescription")#
idx2 <- which(colnames(dat1)=="DependentVariable")#
idx3 <- which(colnames(dat1)=="y")#
idx4 <- which(colnames(dat1)=="v")#
if(idx1!=1){ return("Error: First column of main input data must be ConditionDescription.") }#
if(idx2!=2){ return("Error: Second column of main input data must be DependentVariable.") }#
if(idx4!=(idx3+1)){ return("Error: Column v of main input data must immediately follow column y.") }#
if(!all( c(idx1,idx2,idx3,idx4)==sort(c(idx1,idx2,idx3,idx4)) )){#
	return("Error: Columns of main input data are not properly ordered.") }#
if(idx3==3){#
	messages[[length(messages)+1]] <- "Note: No levels entered. Using the observation as the sole hierarchical level."#
	dat1 <- data.frame( dat1[,1:2], ObsID=1:nrow(dat1), dat1[,-(1:2)] )#
	idx3 <- idx3+1#
	idx4 <- idx4+1#
}#
#
# Group Index Checking I: Checking for duplicate group ID variables#
mv.ml.id <- dat1[,idx2:(idx3-1),drop=FALSE]#
if(ncol(mv.ml.id) > 2){#
	drop.idx <- NULL#
	for(j1 in 3:ncol(mv.ml.id)){#
		for(j2 in 2:(j1-1)){#
			tmpt <- table(mv.ml.id[,j2], mv.ml.id[,j1])#
			tmpr <- rowSums(tmpt>0)#
			tmpc <- colSums(tmpt>0)#
			if(all(tmpr==1) & all(tmpc==1)){ #
				drop.idx <- c(drop.idx, j1)#
				tmpnj1 <- colnames(mv.ml.id)[j1]#
				tmpnj2 <- colnames(mv.ml.id)[j2]#
				messages[[length(messages)+1]] <-  #
					paste0("Note: The group ID variables ",	tmpnj2, " and ", tmpnj1,#
							" give identical groupings. Ignoring ", tmpnj1, ".")#
			}	#
		}#
	}#
	if(!is.null(drop.idx)){ mv.ml.id <- mv.ml.id[,-drop.idx,drop=FALSE] }#
}#
#
# Group Index Checking II: Checking for inner group index with values across #
# multiple outer group index values and giving a warning#
if(ncol(mv.ml.id) > 2){#
	for(i in 2:(ncol(mv.ml.id)-1)){#
		for(j in (i+1):ncol(mv.ml.id)){#
			tmpt <- table(mv.ml.id[,i], mv.ml.id[,j])#
			tmpc <- colSums(tmpt>0)#
			if(any(tmpc > 1)){#
				tmpni <- colnames(mv.ml.id)[i]#
				tmpnj <- colnames(mv.ml.id)[j]#
				messages[[length(messages)+1]] <-  #
					paste0("Note: One or more values of the inner group ID variable ", tmpnj,#
					" appears in more than one value of the outer group ID variable ", tmpni, ".")#
			}			#
		}#
	}#
}#
#
# Build variables#
y <- dat1$y#
dat1$DependentVariable <- as.factor(as.character(dat1$DependentVariable))#
dat1$ConditionDescription <- as.factor(as.character(dat1$ConditionDescription))#
for(i in 1:ncol(mv.ml.id)){ mv.ml.id[,i] <- as.factor(as.character(mv.ml.id[,i])) }#
dumb.vector <- rep(1,length(y))#
#
udv <- levels(dat1$DependentVariable)#
ucond <- levels(dat1$ConditionDescription)#
ulev <- colnames(mv.ml.id)[-1]#
D <- length(unique(mv.ml.id[,1]))		# Number of DVs#
K <- ncol(mv.ml.id) - 1					# Number of Hierarchical Levels (thus K in the code is one less than the K in the manuscript)#
#
# Build standard X matrix#
dv.cond <- as.factor(paste(dat1$DependentVariable, dat1$ConditionDescription, sep=" * "))#
u.dv.cond <- levels(dv.cond)#
X <- matrix(0, length(y), length(u.dv.cond))#
for(i in 1:length(u.dv.cond)){#
	sel <- dv.cond==u.dv.cond[i]#
	X[sel,i] <- 1#
}#
tmp <- which(colSums(X) > 0)#
X <- X[,tmp,drop=FALSE]#
xx.col.names <- u.dv.cond[tmp]#
#
# Add covariates to X#
X1 <- X#
if(ncol(dat1) > idx4){#
	covariate.matrix <- as.matrix( dat1[,(idx4+1):ncol(dat1),drop=FALSE] )#
	for(i in 1:ncol(covariate.matrix)){#
		tmpX <- X * covariate.matrix[,i]#
		tmp <- which(apply(tmpX, 2, sd) > 0)  #
		tmpX <- tmpX[,tmp]#
		X <- cbind(X, tmpX)#
		xx.col.names <- c(xx.col.names, paste(xx.col.names[tmp], colnames(covariate.matrix)[i], sep=" * "))#
	}#
}#
if(ncol(X) > nrow(X)){ return("Error: There are more covariates than rows of data. Reduce the number of covariates.") }#
#
# Set up model evaluation matrices#
reml.ll <- num.param <- matrix(NA, 6, 2)#
colnames(reml.ll) <- colnames(num.param) <- c("MMCS", "EAMMCS")#
rownames(reml.ll) <- rownames(num.param) <- #
	c("Fixed Effects", "Equal Var, Zero Corr", "Equal Var, Single Corr", "Unequal Var, Zero Corr", "Unequal Var, Single Corr", "No Constraints")#
num.param[1,] <- c(0,0)#
num.param[2,] <- c(K,K)#
num.param[3,1] <- K + K*(D>1)#
num.param[3,2] <- K + 1*(D>1)#
num.param[4,1] <- D*K#
num.param[4,2] <- D+K-1#
num.param[5,1] <- D*K + K*(D>1)#
num.param[5,2] <- D+K-1 + 1*(D>1)#
if(eammcs_only){ num.param[,1] <- NA }#
#
# Set up metafor random effects calls#
r.dv.k <- r.k <- list(NULL)#
for(i in 2:ncol(mv.ml.id)){#
	tmps <- paste("~1 | paste(mv.ml.id[, 1], mv.ml.id[, ", i, "], sep = ' - ')", sep="")#
	r.dv.k[[i-1]] <- as.formula(tmps)#
	tmps <- paste("~1 | mv.ml.id[sel, ", i, "]", sep="")#
	r.k[[i-1]] <- as.formula(tmps)#
}#
#
# Fit EAMMCS Fixed Effect Model#
mr.fe <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz.fe, R=Sigma.y, blup=FALSE, eval=TRUE, theta.init=NA)#
#incProgress(0.5/10)
mr.fe
dat1[1:7,]
range(dat$v)
range(dat1$v)
# Fit EAMMCS Equal Variance, Zero Correlation Model#
system.time({ #
tmpm1 <- tmpm2 <- NULL#
try( tmpm1 <- rma.uni(y, diag(Sigma.y), mods=~X-1) )#
try( tmpm2 <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", random=r.dv.k, control=list(maxit=10000)) )#
tmp.init <- rep(0,K)#
if(!is.null(tmpm1)){ tmp.init <- c( log(sqrt( max(tmpm1$tau2,1E-04) )), rep(0,K-1) ) }#
if(!is.null(tmpm2)){#
	if(K==1){ tmp.init <- log(sqrt( max(sum(tmpm2$sigma2),1E-08) ))#
	}else{#
		tmp.init0 <- log(sqrt( max(sum(tmpm2$sigma2),1E-08) ))#
		tmp.init1 <- log(tmpm2$sigma2[1:(K-1)]/tmpm2$sigma2[K])#
		tmp.init1[tmp.init1==Inf] <- 10#
		tmp.init <- c(tmp.init0, tmp.init1)#
	}#
	mr.ea.equalvar.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)	#
}else{#
	mr.ea.equalvar.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.zerocorr, blup=FALSE, eps=1E-08)	#
}#
})#
#incProgress(0.5/10)#
#
# Fit EAMMCS Equal Variance, Single Correlation Model#
if(D==1){ #
	tmp.init <- c(mr.ea.equalvar.zerocorr$theta[1], NA, mr.ea.equalvar.zerocorr$theta[-1])#
	mr.ea.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmp.init <- c( mr.ea.equalvar.zerocorr$theta[1], -3, mr.ea.equalvar.zerocorr$theta[-1] )#
	mr.ea.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.onecorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Fit EAMMCS Unequal Variance, Zero Correlation Model#
if(D==1){ #
	tmp.init <- mr.ea.equalvar.zerocorr$theta#
	mr.ea.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmpm1 <- tmpm2 <- list(NULL)#
	tmp.init <- c( rep(mr.ea.equalvar.zerocorr$theta[1], D), mr.ea.equalvar.zerocorr$theta[-1] )#
	for(i in 1:length(udv)){#
		tmpm1[[i]] <- tmpm2[[i]] <- NA#
		sel <- mv.ml.id[,1]==udv[i]#
		try( tmpm1[[i]] <- rma.uni(y[sel], diag(Sigma.y)[sel], mods=~X[sel,]-1) )#
		try( tmpm2[[i]] <- rma.mv(y[sel], Sigma.y[sel,sel], mods=~X[sel,]-1, struct="CS", random=r.k, control=list(maxit=10000)) )#
		if(!is.na(tmpm1[[i]])){ tmp.init[i] <- log(sqrt( max(tmpm1[[i]]$tau2,1E-04) )) }#
		if(!is.na(tmpm2[[i]])){ tmp.init[i] <- log(sqrt( max(sum(tmpm2[[i]]$sigma2),1E-04) )) }#
	}#
	mr.ea.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.zerocorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Fit EAMMCS Unequal Variance, Single Correlation Model#
if(D==1){ #
	tmp.init <- c(mr.ea.zerocorr$theta[1], NA, mr.ea.zerocorr$theta[-1])#
	mr.ea.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmp.init <- c( mr.ea.zerocorr$theta[1:D], -3, mr.ea.zerocorr$theta[-(1:D)] )#
	mr.ea.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.onecorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Save results of EAMMCS models#
reml.ll[1,] <- -mr.fe$varcomp.opt$value#
reml.ll[2,] <- -min(tryCatch(mr.ea.equalvar.zerocorr$varcomp.opt$value), tryCatch(mr.ea.equalvar.zerocorr$varcomp.opt$objective))#
reml.ll[3,2] <- -mr.ea.equalvar.onecorr$varcomp.opt$value#
reml.ll[4,2] <-  -min(tryCatch(mr.ea.zerocorr$varcomp.opt$value), tryCatch(mr.ea.zerocorr$varcomp.opt$objective))#
reml.ll[5,2] <- -mr.ea.onecorr$varcomp.opt$value#
if(eammcs_only){ reml.ll[1:2,1] <- NA }#
#
if(!eammcs_only){#
	# Fit MMCS Equal Variance, Single Correlation Model#
	# We force positive correlations even though for K==1 and K==2 we can use metafor to get negative#
	# correlations. Nonetheless, we provide a message noting when a negative correlaion improves fit.#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- c(log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] )))#
		mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.equalvar.onecorr.rma.mv <- mr.equalvar.onecorr <- NULL#
			try( mr.equalvar.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2])) )#
			tmp.init <- mr.ea.equalvar.onecorr$theta#
			mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho>0){#
				if( abs(reml.ll[3,1] - logLik(mr.equalvar.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Equal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho<=0){#
				messages[[length(messages)+1]] <- paste0("K=2 MMCS Equal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML LL improves from ", reml.ll[3,1],#
					" to ", logLik(mr.equalvar.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.equalvar.onecorr.rma.mv <- mr.equalvar.onecorr <- NULL#
			try( mr.equalvar.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && mr.equalvar.onecorr.rma.mv$rho>0 && mr.equalvar.onecorr.rma.mv$phi>0){ #
				tmp.init <- c(log(sqrt(mr.equalvar.onecorr.rma.mv$tau2)),#
							  log(sqrt(mr.equalvar.onecorr.rma.mv$gamma2)),#
							  logit(mr.equalvar.onecorr.rma.mv$rho),#
							  logit(mr.equalvar.onecorr.rma.mv$phi))#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.equalvar.onecorr.rma.mv) || mr.equalvar.onecorr.rma.mv$rho<=0 || mr.equalvar.onecorr.rma.mv$phi<=0){#
				tmp.init.convert <- convert.theta.ea.equalvar.onecorr(mr.ea.equalvar.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt(tmp.init.convert[[2]][1]*tmp.init.convert[[3]])),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.equalvar.onecorr)){#
				reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho>0 && mr.equalvar.onecorr.rma.mv$phi>0){#
				if( abs(reml.ll[3,1] - logLik(mr.equalvar.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Equal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && (mr.equalvar.onecorr.rma.mv$rho<=0 || mr.equalvar.onecorr.rma.mv$phi<=0)){#
				messages[[length(messages)+1]] <- paste0("K=3 MMCS Equal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML  LL improves from ", reml.ll[3,1],#
					" to ", logLik(mr.equalvar.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.equalvar.onecorr(mr.ea.equalvar.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt(tmp.init.convert[[2]][1]*tmp.init.convert[[3]])),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.equalvar.onecorr)){#
					reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
				}#
			})#
		}#
	}#
	#incProgress(1.5/10)#
#
	# Fit MMCS Unequal Variance, Zero Correlation Model#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] ))#
		mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# Confirm equivalence of all three#
			mr.zerocorr.rma.mv <- mr.zerocorr <- NULL#
			try( mr.zerocorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2]), rho=0) )#
			tmp.init <- mr.ea.zerocorr$theta#
			mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
			if(!is.null(mr.zerocorr.rma.mv)){#
				if( abs(reml.ll[4,1] - logLik(mr.zerocorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Unequal Variance, Zero Correlation Error." }#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# Confirm equivalence to metafor#
			mr.zerocorr.rma.mv <- mr.zerocorr <- NULL#
			try( mr.zerocorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3]), rho=0, phi=0) )#
			if(!is.null(mr.zerocorr.rma.mv)){ #
				tmp.init <- log(sqrt(as.vector( t(matrix(c(mr.zerocorr.rma.mv$tau2, mr.zerocorr.rma.mv$gamma2), D, K)) )))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.zerocorr.rma.mv)){#
				tmp.init.convert <- convert.theta.ea.zerocorr(mr.ea.zerocorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- log(sqrt( as.vector(t(outer(tmp.init.convert[[2]], tmp.init.convert[[3]]))) ))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.zerocorr)){#
				reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.zerocorr.rma.mv) & !is.null(mr.zerocorr)){#
				if( abs(reml.ll[4,1] - logLik(mr.zerocorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Unequal Variance, Zero Correlation Error." }#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.zerocorr(mr.ea.zerocorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- log(sqrt( as.vector(t(outer(tmp.init.convert[[2]], tmp.init.convert[[3]]))) ))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.zerocorr)){#
					reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
				}#
			})#
		}	#
	}#
	#incProgress(1/10)#
#
	# Fit MMCS Unequal Variance, Single Correlation Model#
	# We force positive correlations even though for K==1 and K==2 we can use metafor to get negative#
	# correlations. Nonetheless, we provide a message noting when a negative correlaion improves fit.#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- c(log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] )))#
		mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# Confirm equivalence of all three#
			mr.onecorr.rma.mv <- mr.onecorr <- NULL#
			try( mr.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2])) )#
			tmp.init <- mr.ea.onecorr$theta#
			mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho>0){#
				if( abs(reml.ll[5,1] - logLik(mr.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Unequal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho<=0){#
				messages[[length(messages)+1]] <- paste0("K=2 MMCS Unequal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML LL improves from ", reml.ll[5,1],#
					" to ", logLik(mr.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.onecorr.rma.mv <- mr.onecorr <- NULL#
			try( mr.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
			if(!is.null(mr.onecorr.rma.mv) && mr.onecorr.rma.mv$rho>0 && mr.onecorr.rma.mv$phi>0){ #
				tmp.init <- c(log(sqrt(mr.onecorr.rma.mv$tau2)),#
							  log(sqrt(mr.onecorr.rma.mv$gamma2)),#
							  logit(mr.onecorr.rma.mv$rho),#
							  logit(mr.onecorr.rma.mv$phi))#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.onecorr.rma.mv) || mr.onecorr.rma.mv$rho<=0 || mr.onecorr.rma.mv$phi<=0){#
				tmp.init.convert <- convert.theta.ea.onecorr(mr.ea.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt( as.vector(outer(tmp.init.convert[[2]], tmp.init.convert[[3]])) )),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.onecorr)){#
				reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho>0 && mr.onecorr.rma.mv$phi>0){#
				if( abs(reml.ll[5,1] - logLik(mr.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Unequal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && (mr.onecorr.rma.mv$rho<=0 || mr.onecorr.rma.mv$phi<=0)){#
				messages[[length(messages)+1]] <- paste0("K=3 MMCS Unequal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML  LL improves from ", reml.ll[5,1],#
					" to ", logLik(mr.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.onecorr(mr.ea.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt( as.vector(outer(tmp.init.convert[[2]], tmp.init.convert[[3]])) )),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.onecorr)){#
					reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
				}#
			})#
		}#
	}#
	#incProgress(1.5/10)#
}else{#
	#incProgress(4/10)#
}#
#
# Fit additional models for K==1 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K==1){#
	system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# However, with No Constraints metafor allows negative correlations while we force positive#
			# correlations so we will fit both#
#
			# MMCS No Constraint#
			mr <- NULL#
			try( mr <- rma.mv(y, Sigma.y, mods=~X-1, struct="UN", control=list(maxit=10000),#
										random=~mv.ml.id[,1]|mv.ml.id[,2]) )#
			if(!is.null(mr) & !eammcs_only){ #
				num.param[6,1] <- sum( unlist(mr$vc.fix)==FALSE, na.rm=TRUE )#
				reml.ll[6,1] <- logLik(mr)#
			}#
	})#
#
	# EAMMCS No Constraint - If all MMCS No Constraint correlations are positive this is #
	# the same model so we will simply evaluate (rather than maximize it) using our code.#
	# But, if all MMCS No Constraint correlations are NOT positive this is we must maximize#
	# using our code#
	mr.ea <- NULL#
	if(D==1){ mr.ea <- mr.ea.equalvar.zerocorr; corr.ind <- numeric(0) }#
	system.time({ if(D!=1 & !is.null(mr) & all(mr$rho >= 0)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- logit(pmin(pmax(mr$rho,1E-08),1-1E-08))#
		tmp <- upper.tri.vec.to.lower.tri.vec(tmp)[corr.ind==1]#
		tmp.init <- c(log(sqrt( pmax(mr$tau2,1E-08) )), tmp)#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eval=TRUE, eps=1E-08) )#
		if(!is.null(mr.ea)){#
			if(abs(-mr.ea$varcomp.opt$value - logLik(mr)) > 1E-04){ #
				messages[[length(messages)+1]] <- "Error: K=2 EAMMCS No Constraint Error." }#
		}	#
	} })#
	system.time({ if(D!=1 & !is.null(mr) & !all(mr$rho >= 0)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- mr.ea.onecorr$theta[D+1]#
		tmp.init <- c(mr.ea.onecorr$theta[1:D], rep(tmp,sum(corr.ind)), mr.ea.onecorr$theta[-(1:(D+1))])#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eps=1E-08) )#
	} })#
	if(!is.null(mr.ea)){#
		num.param[6,2] <- length(mr.ea$theta)#
		reml.ll[6,2] <- -mr.ea$varcomp.opt$value#
	}	#
}#
#
# Fit additional models for K==2 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K==2){#
	system.time({#
		# MMCS No Constraint#
		mr <- NULL#
		try( mr <- rma.mv(y, Sigma.y, mods=~X-1, struct="UN", control=list(maxit=10000),#
								random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
		if(!is.null(mr) & !eammcs_only){ #
			num.param[6,1] <- sum( unlist(mr$vc.fix)==FALSE, na.rm=TRUE ) #
			reml.ll[6,1] <- logLik(mr)#
		}#
	})#
#
	# EAMMCS No Constraint#
	mr.ea <- NULL#
	if(D==1){ mr.ea <- mr.ea.equalvar.zerocorr; corr.ind <- numeric(0)#
	}else{	#
	system.time({ if(!is.null(mr)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE | mr$vc.fix$phi==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- mr.ea.onecorr$theta[D+1]#
		tmp.init <- c(mr.ea.onecorr$theta[1:D], rep(tmp,sum(corr.ind)), mr.ea.onecorr$theta[-(1:(D+1))])#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eval=(D==2), eps=1E-08) )#
	}})}#
	if(!is.null(mr.ea)){#
		num.param[6,2] <- length(mr.ea$theta)#
		reml.ll[6,2] <- -mr.ea$varcomp.opt$value#
	}#
}#
#
# "Fit" additional models for K>2 & D==1 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K>2 & D==1){#
	# When D==1, all models are equivalent to one another (except fixed effects, which differs obviously)#
	if(is.null(tmpm2)){#
		messages[[length(messages)+1]] <- "Error: K>2, D==1 model error."#
		tmpv <- exp(mr.ea.equalvar.zerocorr$theta[1])^2#
		tmpf <- c(mr.ea.equalvar.zerocorr$theta[-1],0)#
		tmpf <- exp(tmpf)/sum(exp(tmpf))#
		tmpm2 <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", random=r.dv.k, sigma2=tmpv*tmpf)#
	}#
#
	if(!eammcs_only){#
		mr <- tmpm2#
		reml.ll[6,1] <- logLik(mr)#
		num.param[6,1] <- K#
	}#
#
	mr.ea <- mr.ea.equalvar.zerocorr#
	corr.ind <- numeric(0)#
	reml.ll[6,2] <- -mr.ea.equalvar.zerocorr$varcomp.opt$value#
	num.param[6,2] <- K	#
}#
if(K>2 & D>1){ mr <- mr.ea <- NULL } #
#incProgress(1/10)#
#
# Store log likelihood results#
results$K <- K+1#
results$D <- D#
results$REML.LL <- reml.ll#
results$Number.of.Variance.Component.Parameters <- num.param#
results$AIC <- 2*num.param - 2*reml.ll#
results$messages <- messages#
#
# Store estimates#
results$estimates <- list()#
if(!eammcs_only){ results$estimates$MMCS <- list() }#
results$estimates$EAMMCS <- list()#
tmpm <- mr.fe#
if(!eammcs_only){#
	results$estimates$MMCS$`Fixed Effects` <- list()#
	results$estimates$MMCS$`Fixed Effects`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Fixed Effects`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Fixed Effects`$vc  <- NA#
}#
tmpm <- mr.fe  # Equivalent to mr.ea.fe#
results$estimates$EAMMCS$`Fixed Effects` <- list()#
results$estimates$EAMMCS$`Fixed Effects`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Fixed Effects`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Fixed Effects`$vc  <- NA#
if(!eammcs_only){#
	tmpm <- mr.ea.equalvar.zerocorr  # Equivalent to mr.equalvar.zerocorr#
	tmpvc <- convert.theta.ea.equalvar.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Equal Var, Zero Corr` <- list()#
	results$estimates$MMCS$`Equal Var, Zero Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Equal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
	tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
	results$estimates$MMCS$`Equal Var, Zero Corr`$vc$variance  <- data.frame(tmpd)#
}#
tmpm <- mr.ea.equalvar.zerocorr#
tmpvc <- convert.theta.ea.equalvar.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
results$estimates$EAMMCS$`Equal Var, Zero Corr` <- list()#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$variance  <- tmpvc[[2]][1]#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.equalvar.onecorr#
	tmpvc <- convert.theta.equalvar.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Equal Var, Single Corr` <- list()#
	results$estimates$MMCS$`Equal Var, Single Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Equal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Equal Var, Single Corr`$vc$variance  <- apply(tmpvc[[1]], 3, function(x){x[1,1]})#
	if(D==1){#
		tmpcorr <- results$estimates$MMCS$`Equal Var, Single Corr`$vc$variance#
		tmpcorr[1:K] <- NA#
		results$estimates$MMCS$`Equal Var, Single Corr`$vc$correlation <- tmpcorr#
	}else{#
		results$estimates$MMCS$`Equal Var, Single Corr`$vc$correlation  <- apply(tmpvc[[1]], 3, function(x){cov2cor(x)[2,1]})#
	}		#
}#
tmpm <- mr.ea.equalvar.onecorr#
tmpvc <- convert.theta.ea.equalvar.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
tmpr <- ifelse(D==1, NA, unique(as.vector(tmpvc[[4]][ !is.na(tmpvc[[4]]) ])))#
results$estimates$EAMMCS$`Equal Var, Single Corr` <- list()#
results$estimates$EAMMCS$`Equal Var, Single Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$variance  <- tmpvc[[2]][1]#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$correlation  <- tmpr		#
tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.zerocorr#
	tmpvc <- convert.theta.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Unequal Var, Zero Corr` <- list()#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$vc$variance  <- apply(tmpvc[[1]], 3, diag)#
}#
tmpm <- mr.ea.zerocorr#
tmpvc <- convert.theta.ea.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
results$estimates$EAMMCS$`Unequal Var, Zero Corr` <- list()#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.onecorr#
	tmpvc <- convert.theta.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Unequal Var, Single Corr` <- list()#
	results$estimates$MMCS$`Unequal Var, Single Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Unequal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Unequal Var, Single Corr`$vc$variance  <- apply(tmpvc[[1]], 3, diag)#
	if(D==1){#
		tmpcorr <- results$estimates$MMCS$`Unequal Var, Single Corr`$vc$variance#
		tmpcorr[1:K] <- NA#
		results$estimates$MMCS$`Unequal Var, Single Corr`$vc$correlation <- tmpcorr#
	}else{#
		results$estimates$MMCS$`Unequal Var, Single Corr`$vc$correlation  <- apply(tmpvc[[1]], 3, function(x){cov2cor(x)[2,1]})#
	}#
}#
tmpm <- mr.ea.onecorr#
tmpvc <- convert.theta.ea.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
tmpr <- ifelse(D==1, NA, unique(as.vector(tmpvc[[4]][ !is.na(tmpvc[[4]]) ])))#
results$estimates$EAMMCS$`Unequal Var, Single Corr` <- list()#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$correlation  <- tmpr		#
tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	if(K<=2 && !is.null(mr)){#
		tmpm <- mr#
		results$estimates$MMCS$`No Constraints` <- list()#
		results$estimates$MMCS$`No Constraints`$fe.estimates  <-#
			data.frame( Estimate=as.vector(tmpm$b), SE=as.vector(tmpm$se), row.names=xx.col.names )#
		results$estimates$MMCS$`No Constraints`$fe.vcv  <- unname(tmpm$vb)#
		if(K==1){#
			tmpd <- matrix( tmpm$tau2, ncol=K, dimnames=list(udv,ulev) )#
		}else{#
			tmpd <- cbind( tmpm$tau2, tmpm$gamma2 )#
			dimnames(tmpd) <- list(udv, ulev)#
		}#
		results$estimates$MMCS$`No Constraints`$vc$variance  <- data.frame(tmpd)				#
		tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
		tmprr[upper.tri(tmprr)] <- tmpm$rho#
		tmprr <- tmprr + t(tmprr)#
		diag(tmprr) <- 1#
		if(K==1){#
			results$estimates$MMCS$`No Constraints`$vc[[2]]  <- data.frame(tmprr)#
		}else{#
			results$estimates$MMCS$`No Constraints`$vc[[2]]  <- data.frame(tmprr)					#
			tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
			tmprr[upper.tri(tmprr)] <- tmpm$phi#
			tmprr <- tmprr + t(tmprr)#
			diag(tmprr) <- 1#
			results$estimates$MMCS$`No Constraints`$vc[[3]]  <- data.frame(tmprr)					#
		}#
		names(results$estimates$MMCS$`No Constraints`$vc)[-1] <- paste0("correlation.",ulev)#
	}#
	if(K>2 && !is.null(mr)){#
		tmpm <- mr#
		results$estimates$MMCS$`No Constraints` <- list()#
		results$estimates$MMCS$`No Constraints`$fe.estimates  <-#
			data.frame( Estimate=as.vector(tmpm$b), SE=as.vector(tmpm$se), row.names=xx.col.names )#
		results$estimates$MMCS$`No Constraints`$fe.vcv  <- unname(tmpm$vb)#
		tmpd <- matrix( tmpm$sigma2, ncol=K, dimnames=list(udv,ulev) )#
		results$estimates$MMCS$`No Constraints`$vc$variance  <- data.frame(tmpd)#
		tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
		tmprr[upper.tri(tmprr)] <- tmpm$rho#
		tmprr <- tmprr + t(tmprr)#
		diag(tmprr) <- 1#
		for(i in 1:K){ results$estimates$MMCS$`No Constraints`$vc[[i+1]] <- data.frame(tmprr) }#
		names(results$estimates$MMCS$`No Constraints`$vc)[-1] <- paste0("correlation.", ulev)#
	}#
}#
if(!is.null(mr.ea)){#
	tmpm <- mr.ea#
	tmpvc <- convert.theta.ea.nc.custom( tmpm$theta, mv.ml.id, 1E-08, corr.ind )#
	results$estimates$EAMMCS$`No Constraints` <- list()#
	results$estimates$EAMMCS$`No Constraints`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$EAMMCS$`No Constraints`$fe.vcv  <- tmpm$covariance#
	results$estimates$EAMMCS$`No Constraints`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
	results$estimates$EAMMCS$`No Constraints`$vc$allocation  <-#
		data.frame( allocation=tmpvc[[3]], row.names=ulev )#
	tmprr <- tmpvc[[4]]#
	tmprr[upper.tri(tmprr,diag=TRUE)] <- 0#
	tmprr <- tmprr + t(tmprr)#
	diag(tmprr) <- 1#
	dimnames(tmprr) <- list(udv, udv)#
	results$estimates$EAMMCS$`No Constraints`$vc$correlation  <- data.frame(tmprr)#
	tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
	for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
	results$estimates$EAMMCS$`No Constraints`$vc$implied.variance <- data.frame(tmpd)#
	results$estimates$EAMMCS$`No Constraints`$vc$implied.vcv <- tmpvc[[1]]#
}
library(foreign)#
dat <- data.frame(read.spss("/Users/blakemcshane/Dropbox/Dropbox Research/Blake_Ulf/PowerCalculations/Analysis/uncertainty_and_heterogeneity/manylabs/Data/CleanedDataset.sav"))
dim(dat)
t(colnames(dat))
t(t(colnames(dat)))
library(abind)
?abind
dat1 <- read.csv("mydata-02.25.22.csv", header=TRUE)
dat1[1:5,]
table(dat1$DependentVariable)
which(dat1$DependentVariable=="Att",)
which(dat1$DependentVariable=="Behavior",)
dat1 <- read.csv("mydata-02.25.22.csv", header=TRUE)#
dat2 <- NULL#
eammcs_only <- FALSE#
# If no dat2: 		dat2 <- NULL
dat1[1:5,]
dat1[dat1$DependentVariable=="Behavior",]
dat1[1:10,]
dat1[1:16,]
dat1[dat1$StudyID==43,]
dim(dat1)
dat1 <- dat1[dat1$DependentVariable!="Behavior",]
dim(dat1)
eammcs_only <- FALSE
library(metafor)#
source("aux.general.D.R")#
source("aux.reml.aux.blup.optim.option.R")#
results <- messages <- list()#
#
date()#
#
# Error checking I:#
if(is.null(dat1)){ return("Error: No main input data provided.") }#
if(any(is.na(dat1))){ return("Error: No NAs allowed in main input data.") }#
if(ncol(dat1) < 4){ return("Error: Main input data has less than four columns. It must have at minimum four columns.") }#
if(!is.null(dat2)){#
	if(any(is.na(dat2))){ return("Error: No NAs allowed in error variance covariance matrix.") }#
	if(nrow(dat1)!=nrow(dat2)){ return("Error: Main input data and error variance covariance matrix have a different number of rows.") }#
	if(nrow(dat2)!=ncol(dat2)){ return("Error: The error variance covariance matrix must be square.") }#
	Sigma.y <- as.matrix(dat2)#
	M <- max(abs( Sigma.y - t(Sigma.y) ))#
	if(M > 1E-08){ return("Error: The error variance covariance matrix must be symmetric.") }#
	m <- min(eigen(Sigma.y,only.values=TRUE)$values)#
	if(m < 1E-08){ return("Error: The error variance covariance matrix must be positive definite.") }#
	M <- max(abs( diag(Sigma.y) - dat1$v ))#
	if(M > 1E-08){ messages[[length(messages)+1]] <- paste0("Note: The diagonal of the error ",   #
		"variance covariance matrix and the v column of the main input data do not match. As always ",#
		"when an error variance covariance matrix is provided, using the error variance covariance ",#
		"matrix and ignoring the v column of the main input data.") }#
}else{#
	Sigma.y <- diag(dat1$v)#
}#
#
# Error checking II:#
idx1 <- which(colnames(dat1)=="ConditionDescription")#
idx2 <- which(colnames(dat1)=="DependentVariable")#
idx3 <- which(colnames(dat1)=="y")#
idx4 <- which(colnames(dat1)=="v")#
if(idx1!=1){ return("Error: First column of main input data must be ConditionDescription.") }#
if(idx2!=2){ return("Error: Second column of main input data must be DependentVariable.") }#
if(idx4!=(idx3+1)){ return("Error: Column v of main input data must immediately follow column y.") }#
if(!all( c(idx1,idx2,idx3,idx4)==sort(c(idx1,idx2,idx3,idx4)) )){#
	return("Error: Columns of main input data are not properly ordered.") }#
if(idx3==3){#
	messages[[length(messages)+1]] <- "Note: No levels entered. Using the observation as the sole hierarchical level."#
	dat1 <- data.frame( dat1[,1:2], ObsID=1:nrow(dat1), dat1[,-(1:2)] )#
	idx3 <- idx3+1#
	idx4 <- idx4+1#
}#
#
# Group Index Checking I: Checking for duplicate group ID variables#
mv.ml.id <- dat1[,idx2:(idx3-1),drop=FALSE]#
if(ncol(mv.ml.id) > 2){#
	drop.idx <- NULL#
	for(j1 in 3:ncol(mv.ml.id)){#
		for(j2 in 2:(j1-1)){#
			tmpt <- table(mv.ml.id[,j2], mv.ml.id[,j1])#
			tmpr <- rowSums(tmpt>0)#
			tmpc <- colSums(tmpt>0)#
			if(all(tmpr==1) & all(tmpc==1)){ #
				drop.idx <- c(drop.idx, j1)#
				tmpnj1 <- colnames(mv.ml.id)[j1]#
				tmpnj2 <- colnames(mv.ml.id)[j2]#
				messages[[length(messages)+1]] <-  #
					paste0("Note: The group ID variables ",	tmpnj2, " and ", tmpnj1,#
							" give identical groupings. Ignoring ", tmpnj1, ".")#
			}	#
		}#
	}#
	if(!is.null(drop.idx)){ mv.ml.id <- mv.ml.id[,-drop.idx,drop=FALSE] }#
}#
#
# Group Index Checking II: Checking for inner group index with values across #
# multiple outer group index values and giving a warning#
if(ncol(mv.ml.id) > 2){#
	for(i in 2:(ncol(mv.ml.id)-1)){#
		for(j in (i+1):ncol(mv.ml.id)){#
			tmpt <- table(mv.ml.id[,i], mv.ml.id[,j])#
			tmpc <- colSums(tmpt>0)#
			if(any(tmpc > 1)){#
				tmpni <- colnames(mv.ml.id)[i]#
				tmpnj <- colnames(mv.ml.id)[j]#
				messages[[length(messages)+1]] <-  #
					paste0("Note: One or more values of the inner group ID variable ", tmpnj,#
					" appears in more than one value of the outer group ID variable ", tmpni, ".")#
			}			#
		}#
	}#
}#
#
# Build variables#
y <- dat1$y#
dat1$DependentVariable <- as.factor(as.character(dat1$DependentVariable))#
dat1$ConditionDescription <- as.factor(as.character(dat1$ConditionDescription))#
for(i in 1:ncol(mv.ml.id)){ mv.ml.id[,i] <- as.factor(as.character(mv.ml.id[,i])) }#
dumb.vector <- rep(1,length(y))#
#
udv <- levels(dat1$DependentVariable)#
ucond <- levels(dat1$ConditionDescription)#
ulev <- colnames(mv.ml.id)[-1]#
D <- length(unique(mv.ml.id[,1]))		# Number of DVs#
K <- ncol(mv.ml.id) - 1					# Number of Hierarchical Levels (thus K in the code is one less than the K in the manuscript)#
#
# Build standard X matrix#
dv.cond <- as.factor(paste(dat1$DependentVariable, dat1$ConditionDescription, sep=" * "))#
u.dv.cond <- levels(dv.cond)#
X <- matrix(0, length(y), length(u.dv.cond))#
for(i in 1:length(u.dv.cond)){#
	sel <- dv.cond==u.dv.cond[i]#
	X[sel,i] <- 1#
}#
tmp <- which(colSums(X) > 0)#
X <- X[,tmp,drop=FALSE]#
xx.col.names <- u.dv.cond[tmp]#
#
# Add covariates to X#
X1 <- X#
if(ncol(dat1) > idx4){#
	covariate.matrix <- as.matrix( dat1[,(idx4+1):ncol(dat1),drop=FALSE] )#
	for(i in 1:ncol(covariate.matrix)){#
		tmpX <- X * covariate.matrix[,i]#
		tmp <- which(apply(tmpX, 2, sd) > 0)  #
		tmpX <- tmpX[,tmp]#
		X <- cbind(X, tmpX)#
		xx.col.names <- c(xx.col.names, paste(xx.col.names[tmp], colnames(covariate.matrix)[i], sep=" * "))#
	}#
}#
if(ncol(X) > nrow(X)){ return("Error: There are more covariates than rows of data. Reduce the number of covariates.") }#
#
# Set up model evaluation matrices#
reml.ll <- num.param <- matrix(NA, 6, 2)#
colnames(reml.ll) <- colnames(num.param) <- c("MMCS", "EAMMCS")#
rownames(reml.ll) <- rownames(num.param) <- #
	c("Fixed Effects", "Equal Var, Zero Corr", "Equal Var, Single Corr", "Unequal Var, Zero Corr", "Unequal Var, Single Corr", "No Constraints")#
num.param[1,] <- c(0,0)#
num.param[2,] <- c(K,K)#
num.param[3,1] <- K + K*(D>1)#
num.param[3,2] <- K + 1*(D>1)#
num.param[4,1] <- D*K#
num.param[4,2] <- D+K-1#
num.param[5,1] <- D*K + K*(D>1)#
num.param[5,2] <- D+K-1 + 1*(D>1)#
if(eammcs_only){ num.param[,1] <- NA }#
#
# Set up metafor random effects calls#
r.dv.k <- r.k <- list(NULL)#
for(i in 2:ncol(mv.ml.id)){#
	tmps <- paste("~1 | paste(mv.ml.id[, 1], mv.ml.id[, ", i, "], sep = ' - ')", sep="")#
	r.dv.k[[i-1]] <- as.formula(tmps)#
	tmps <- paste("~1 | mv.ml.id[sel, ", i, "]", sep="")#
	r.k[[i-1]] <- as.formula(tmps)#
}#
#
# Fit EAMMCS Fixed Effect Model#
mr.fe <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz.fe, R=Sigma.y, blup=FALSE, eval=TRUE, theta.init=NA)#
#incProgress(0.5/10)#
#
# Fit EAMMCS Equal Variance, Zero Correlation Model#
system.time({ #
tmpm1 <- tmpm2 <- NULL#
try( tmpm1 <- rma.uni(y, diag(Sigma.y), mods=~X-1) )#
try( tmpm2 <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", random=r.dv.k, control=list(maxit=10000)) )#
tmp.init <- rep(0,K)#
if(!is.null(tmpm1)){ tmp.init <- c( log(sqrt( max(tmpm1$tau2,1E-04) )), rep(0,K-1) ) }#
if(!is.null(tmpm2)){#
	if(K==1){ tmp.init <- log(sqrt( max(sum(tmpm2$sigma2),1E-08) ))#
	}else{#
		tmp.init0 <- log(sqrt( max(sum(tmpm2$sigma2),1E-08) ))#
		tmp.init1 <- log(tmpm2$sigma2[1:(K-1)]/tmpm2$sigma2[K])#
		tmp.init1[tmp.init1==Inf] <- 10#
		tmp.init <- c(tmp.init0, tmp.init1)#
	}#
	mr.ea.equalvar.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)	#
}else{#
	mr.ea.equalvar.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.zerocorr, blup=FALSE, eps=1E-08)	#
}#
})#
#incProgress(0.5/10)#
#
# Fit EAMMCS Equal Variance, Single Correlation Model#
if(D==1){ #
	tmp.init <- c(mr.ea.equalvar.zerocorr$theta[1], NA, mr.ea.equalvar.zerocorr$theta[-1])#
	mr.ea.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmp.init <- c( mr.ea.equalvar.zerocorr$theta[1], -3, mr.ea.equalvar.zerocorr$theta[-1] )#
	mr.ea.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.onecorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Fit EAMMCS Unequal Variance, Zero Correlation Model#
if(D==1){ #
	tmp.init <- mr.ea.equalvar.zerocorr$theta#
	mr.ea.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmpm1 <- tmpm2 <- list(NULL)#
	tmp.init <- c( rep(mr.ea.equalvar.zerocorr$theta[1], D), mr.ea.equalvar.zerocorr$theta[-1] )#
	for(i in 1:length(udv)){#
		tmpm1[[i]] <- tmpm2[[i]] <- NA#
		sel <- mv.ml.id[,1]==udv[i]#
		try( tmpm1[[i]] <- rma.uni(y[sel], diag(Sigma.y)[sel], mods=~X[sel,]-1) )#
		try( tmpm2[[i]] <- rma.mv(y[sel], Sigma.y[sel,sel], mods=~X[sel,]-1, struct="CS", random=r.k, control=list(maxit=10000)) )#
		if(!is.na(tmpm1[[i]])){ tmp.init[i] <- log(sqrt( max(tmpm1[[i]]$tau2,1E-04) )) }#
		if(!is.na(tmpm2[[i]])){ tmp.init[i] <- log(sqrt( max(sum(tmpm2[[i]]$sigma2),1E-04) )) }#
	}#
	mr.ea.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.zerocorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Fit EAMMCS Unequal Variance, Single Correlation Model#
if(D==1){ #
	tmp.init <- c(mr.ea.zerocorr$theta[1], NA, mr.ea.zerocorr$theta[-1])#
	mr.ea.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmp.init <- c( mr.ea.zerocorr$theta[1:D], -3, mr.ea.zerocorr$theta[-(1:D)] )#
	mr.ea.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.onecorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Save results of EAMMCS models#
reml.ll[1,] <- -mr.fe$varcomp.opt$value#
reml.ll[2,] <- -min(tryCatch(mr.ea.equalvar.zerocorr$varcomp.opt$value), tryCatch(mr.ea.equalvar.zerocorr$varcomp.opt$objective))#
reml.ll[3,2] <- -mr.ea.equalvar.onecorr$varcomp.opt$value#
reml.ll[4,2] <-  -min(tryCatch(mr.ea.zerocorr$varcomp.opt$value), tryCatch(mr.ea.zerocorr$varcomp.opt$objective))#
reml.ll[5,2] <- -mr.ea.onecorr$varcomp.opt$value#
if(eammcs_only){ reml.ll[1:2,1] <- NA }#
#
if(!eammcs_only){#
	# Fit MMCS Equal Variance, Single Correlation Model#
	# We force positive correlations even though for K==1 and K==2 we can use metafor to get negative#
	# correlations. Nonetheless, we provide a message noting when a negative correlaion improves fit.#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- c(log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] )))#
		mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.equalvar.onecorr.rma.mv <- mr.equalvar.onecorr <- NULL#
			try( mr.equalvar.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2])) )#
			tmp.init <- mr.ea.equalvar.onecorr$theta#
			mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho>0){#
				if( abs(reml.ll[3,1] - logLik(mr.equalvar.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Equal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho<=0){#
				messages[[length(messages)+1]] <- paste0("K=2 MMCS Equal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML LL improves from ", reml.ll[3,1],#
					" to ", logLik(mr.equalvar.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.equalvar.onecorr.rma.mv <- mr.equalvar.onecorr <- NULL#
			try( mr.equalvar.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && mr.equalvar.onecorr.rma.mv$rho>0 && mr.equalvar.onecorr.rma.mv$phi>0){ #
				tmp.init <- c(log(sqrt(mr.equalvar.onecorr.rma.mv$tau2)),#
							  log(sqrt(mr.equalvar.onecorr.rma.mv$gamma2)),#
							  logit(mr.equalvar.onecorr.rma.mv$rho),#
							  logit(mr.equalvar.onecorr.rma.mv$phi))#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.equalvar.onecorr.rma.mv) || mr.equalvar.onecorr.rma.mv$rho<=0 || mr.equalvar.onecorr.rma.mv$phi<=0){#
				tmp.init.convert <- convert.theta.ea.equalvar.onecorr(mr.ea.equalvar.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt(tmp.init.convert[[2]][1]*tmp.init.convert[[3]])),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.equalvar.onecorr)){#
				reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho>0 && mr.equalvar.onecorr.rma.mv$phi>0){#
				if( abs(reml.ll[3,1] - logLik(mr.equalvar.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Equal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && (mr.equalvar.onecorr.rma.mv$rho<=0 || mr.equalvar.onecorr.rma.mv$phi<=0)){#
				messages[[length(messages)+1]] <- paste0("K=3 MMCS Equal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML  LL improves from ", reml.ll[3,1],#
					" to ", logLik(mr.equalvar.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.equalvar.onecorr(mr.ea.equalvar.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt(tmp.init.convert[[2]][1]*tmp.init.convert[[3]])),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.equalvar.onecorr)){#
					reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
				}#
			})#
		}#
	}#
	#incProgress(1.5/10)#
#
	# Fit MMCS Unequal Variance, Zero Correlation Model#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] ))#
		mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# Confirm equivalence of all three#
			mr.zerocorr.rma.mv <- mr.zerocorr <- NULL#
			try( mr.zerocorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2]), rho=0) )#
			tmp.init <- mr.ea.zerocorr$theta#
			mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
			if(!is.null(mr.zerocorr.rma.mv)){#
				if( abs(reml.ll[4,1] - logLik(mr.zerocorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Unequal Variance, Zero Correlation Error." }#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# Confirm equivalence to metafor#
			mr.zerocorr.rma.mv <- mr.zerocorr <- NULL#
			try( mr.zerocorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3]), rho=0, phi=0) )#
			if(!is.null(mr.zerocorr.rma.mv)){ #
				tmp.init <- log(sqrt(as.vector( t(matrix(c(mr.zerocorr.rma.mv$tau2, mr.zerocorr.rma.mv$gamma2), D, K)) )))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.zerocorr.rma.mv)){#
				tmp.init.convert <- convert.theta.ea.zerocorr(mr.ea.zerocorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- log(sqrt( as.vector(t(outer(tmp.init.convert[[2]], tmp.init.convert[[3]]))) ))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.zerocorr)){#
				reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.zerocorr.rma.mv) & !is.null(mr.zerocorr)){#
				if( abs(reml.ll[4,1] - logLik(mr.zerocorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Unequal Variance, Zero Correlation Error." }#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.zerocorr(mr.ea.zerocorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- log(sqrt( as.vector(t(outer(tmp.init.convert[[2]], tmp.init.convert[[3]]))) ))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.zerocorr)){#
					reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
				}#
			})#
		}	#
	}#
	#incProgress(1/10)#
#
	# Fit MMCS Unequal Variance, Single Correlation Model#
	# We force positive correlations even though for K==1 and K==2 we can use metafor to get negative#
	# correlations. Nonetheless, we provide a message noting when a negative correlaion improves fit.#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- c(log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] )))#
		mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# Confirm equivalence of all three#
			mr.onecorr.rma.mv <- mr.onecorr <- NULL#
			try( mr.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2])) )#
			tmp.init <- mr.ea.onecorr$theta#
			mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho>0){#
				if( abs(reml.ll[5,1] - logLik(mr.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Unequal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho<=0){#
				messages[[length(messages)+1]] <- paste0("K=2 MMCS Unequal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML LL improves from ", reml.ll[5,1],#
					" to ", logLik(mr.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.onecorr.rma.mv <- mr.onecorr <- NULL#
			try( mr.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
			if(!is.null(mr.onecorr.rma.mv) && mr.onecorr.rma.mv$rho>0 && mr.onecorr.rma.mv$phi>0){ #
				tmp.init <- c(log(sqrt(mr.onecorr.rma.mv$tau2)),#
							  log(sqrt(mr.onecorr.rma.mv$gamma2)),#
							  logit(mr.onecorr.rma.mv$rho),#
							  logit(mr.onecorr.rma.mv$phi))#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.onecorr.rma.mv) || mr.onecorr.rma.mv$rho<=0 || mr.onecorr.rma.mv$phi<=0){#
				tmp.init.convert <- convert.theta.ea.onecorr(mr.ea.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt( as.vector(outer(tmp.init.convert[[2]], tmp.init.convert[[3]])) )),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.onecorr)){#
				reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho>0 && mr.onecorr.rma.mv$phi>0){#
				if( abs(reml.ll[5,1] - logLik(mr.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Unequal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && (mr.onecorr.rma.mv$rho<=0 || mr.onecorr.rma.mv$phi<=0)){#
				messages[[length(messages)+1]] <- paste0("K=3 MMCS Unequal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML  LL improves from ", reml.ll[5,1],#
					" to ", logLik(mr.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.onecorr(mr.ea.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt( as.vector(outer(tmp.init.convert[[2]], tmp.init.convert[[3]])) )),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.onecorr)){#
					reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
				}#
			})#
		}#
	}#
	#incProgress(1.5/10)#
}else{#
	#incProgress(4/10)#
}#
#
# Fit additional models for K==1 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K==1){#
	system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# However, with No Constraints metafor allows negative correlations while we force positive#
			# correlations so we will fit both#
#
			# MMCS No Constraint#
			mr <- NULL#
			try( mr <- rma.mv(y, Sigma.y, mods=~X-1, struct="UN", control=list(maxit=10000),#
										random=~mv.ml.id[,1]|mv.ml.id[,2]) )#
			if(!is.null(mr) & !eammcs_only){ #
				num.param[6,1] <- sum( unlist(mr$vc.fix)==FALSE, na.rm=TRUE )#
				reml.ll[6,1] <- logLik(mr)#
			}#
	})#
#
	# EAMMCS No Constraint - If all MMCS No Constraint correlations are positive this is #
	# the same model so we will simply evaluate (rather than maximize it) using our code.#
	# But, if all MMCS No Constraint correlations are NOT positive this is we must maximize#
	# using our code#
	mr.ea <- NULL#
	if(D==1){ mr.ea <- mr.ea.equalvar.zerocorr; corr.ind <- numeric(0) }#
	system.time({ if(D!=1 & !is.null(mr) & all(mr$rho >= 0)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- logit(pmin(pmax(mr$rho,1E-08),1-1E-08))#
		tmp <- upper.tri.vec.to.lower.tri.vec(tmp)[corr.ind==1]#
		tmp.init <- c(log(sqrt( pmax(mr$tau2,1E-08) )), tmp)#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eval=TRUE, eps=1E-08) )#
		if(!is.null(mr.ea)){#
			if(abs(-mr.ea$varcomp.opt$value - logLik(mr)) > 1E-04){ #
				messages[[length(messages)+1]] <- "Error: K=2 EAMMCS No Constraint Error." }#
		}	#
	} })#
	system.time({ if(D!=1 & !is.null(mr) & !all(mr$rho >= 0)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- mr.ea.onecorr$theta[D+1]#
		tmp.init <- c(mr.ea.onecorr$theta[1:D], rep(tmp,sum(corr.ind)), mr.ea.onecorr$theta[-(1:(D+1))])#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eps=1E-08) )#
	} })#
	if(!is.null(mr.ea)){#
		num.param[6,2] <- length(mr.ea$theta)#
		reml.ll[6,2] <- -mr.ea$varcomp.opt$value#
	}	#
}#
#
# Fit additional models for K==2 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K==2){#
	system.time({#
		# MMCS No Constraint#
		mr <- NULL#
		try( mr <- rma.mv(y, Sigma.y, mods=~X-1, struct="UN", control=list(maxit=10000),#
								random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
		if(!is.null(mr) & !eammcs_only){ #
			num.param[6,1] <- sum( unlist(mr$vc.fix)==FALSE, na.rm=TRUE ) #
			reml.ll[6,1] <- logLik(mr)#
		}#
	})#
#
	# EAMMCS No Constraint#
	mr.ea <- NULL#
	if(D==1){ mr.ea <- mr.ea.equalvar.zerocorr; corr.ind <- numeric(0)#
	}else{	#
	system.time({ if(!is.null(mr)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE | mr$vc.fix$phi==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- mr.ea.onecorr$theta[D+1]#
		tmp.init <- c(mr.ea.onecorr$theta[1:D], rep(tmp,sum(corr.ind)), mr.ea.onecorr$theta[-(1:(D+1))])#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eval=(D==2), eps=1E-08) )#
	}})}#
	if(!is.null(mr.ea)){#
		num.param[6,2] <- length(mr.ea$theta)#
		reml.ll[6,2] <- -mr.ea$varcomp.opt$value#
	}#
}#
#
# "Fit" additional models for K>2 & D==1 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K>2 & D==1){#
	# When D==1, all models are equivalent to one another (except fixed effects, which differs obviously)#
	if(is.null(tmpm2)){#
		messages[[length(messages)+1]] <- "Error: K>2, D==1 model error."#
		tmpv <- exp(mr.ea.equalvar.zerocorr$theta[1])^2#
		tmpf <- c(mr.ea.equalvar.zerocorr$theta[-1],0)#
		tmpf <- exp(tmpf)/sum(exp(tmpf))#
		tmpm2 <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", random=r.dv.k, sigma2=tmpv*tmpf)#
	}#
#
	if(!eammcs_only){#
		mr <- tmpm2#
		reml.ll[6,1] <- logLik(mr)#
		num.param[6,1] <- K#
	}#
#
	mr.ea <- mr.ea.equalvar.zerocorr#
	corr.ind <- numeric(0)#
	reml.ll[6,2] <- -mr.ea.equalvar.zerocorr$varcomp.opt$value#
	num.param[6,2] <- K	#
}#
if(K>2 & D>1){ mr <- mr.ea <- NULL } #
#incProgress(1/10)#
#
# Store log likelihood results#
results$K <- K+1#
results$D <- D#
results$REML.LL <- reml.ll#
results$Number.of.Variance.Component.Parameters <- num.param#
results$AIC <- 2*num.param - 2*reml.ll#
results$messages <- messages#
#
# Store estimates#
results$estimates <- list()#
if(!eammcs_only){ results$estimates$MMCS <- list() }#
results$estimates$EAMMCS <- list()#
tmpm <- mr.fe#
if(!eammcs_only){#
	results$estimates$MMCS$`Fixed Effects` <- list()#
	results$estimates$MMCS$`Fixed Effects`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Fixed Effects`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Fixed Effects`$vc  <- NA#
}#
tmpm <- mr.fe  # Equivalent to mr.ea.fe#
results$estimates$EAMMCS$`Fixed Effects` <- list()#
results$estimates$EAMMCS$`Fixed Effects`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Fixed Effects`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Fixed Effects`$vc  <- NA#
if(!eammcs_only){#
	tmpm <- mr.ea.equalvar.zerocorr  # Equivalent to mr.equalvar.zerocorr#
	tmpvc <- convert.theta.ea.equalvar.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Equal Var, Zero Corr` <- list()#
	results$estimates$MMCS$`Equal Var, Zero Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Equal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
	tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
	results$estimates$MMCS$`Equal Var, Zero Corr`$vc$variance  <- data.frame(tmpd)#
}#
tmpm <- mr.ea.equalvar.zerocorr#
tmpvc <- convert.theta.ea.equalvar.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
results$estimates$EAMMCS$`Equal Var, Zero Corr` <- list()#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$variance  <- tmpvc[[2]][1]#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.equalvar.onecorr#
	tmpvc <- convert.theta.equalvar.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Equal Var, Single Corr` <- list()#
	results$estimates$MMCS$`Equal Var, Single Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Equal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Equal Var, Single Corr`$vc$variance  <- apply(tmpvc[[1]], 3, function(x){x[1,1]})#
	if(D==1){#
		tmpcorr <- results$estimates$MMCS$`Equal Var, Single Corr`$vc$variance#
		tmpcorr[1:K] <- NA#
		results$estimates$MMCS$`Equal Var, Single Corr`$vc$correlation <- tmpcorr#
	}else{#
		results$estimates$MMCS$`Equal Var, Single Corr`$vc$correlation  <- apply(tmpvc[[1]], 3, function(x){cov2cor(x)[2,1]})#
	}		#
}#
tmpm <- mr.ea.equalvar.onecorr#
tmpvc <- convert.theta.ea.equalvar.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
tmpr <- ifelse(D==1, NA, unique(as.vector(tmpvc[[4]][ !is.na(tmpvc[[4]]) ])))#
results$estimates$EAMMCS$`Equal Var, Single Corr` <- list()#
results$estimates$EAMMCS$`Equal Var, Single Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$variance  <- tmpvc[[2]][1]#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$correlation  <- tmpr		#
tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.zerocorr#
	tmpvc <- convert.theta.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Unequal Var, Zero Corr` <- list()#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$vc$variance  <- apply(tmpvc[[1]], 3, diag)#
}#
tmpm <- mr.ea.zerocorr#
tmpvc <- convert.theta.ea.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
results$estimates$EAMMCS$`Unequal Var, Zero Corr` <- list()#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.onecorr#
	tmpvc <- convert.theta.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Unequal Var, Single Corr` <- list()#
	results$estimates$MMCS$`Unequal Var, Single Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Unequal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Unequal Var, Single Corr`$vc$variance  <- apply(tmpvc[[1]], 3, diag)#
	if(D==1){#
		tmpcorr <- results$estimates$MMCS$`Unequal Var, Single Corr`$vc$variance#
		tmpcorr[1:K] <- NA#
		results$estimates$MMCS$`Unequal Var, Single Corr`$vc$correlation <- tmpcorr#
	}else{#
		results$estimates$MMCS$`Unequal Var, Single Corr`$vc$correlation  <- apply(tmpvc[[1]], 3, function(x){cov2cor(x)[2,1]})#
	}#
}#
tmpm <- mr.ea.onecorr#
tmpvc <- convert.theta.ea.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
tmpr <- ifelse(D==1, NA, unique(as.vector(tmpvc[[4]][ !is.na(tmpvc[[4]]) ])))#
results$estimates$EAMMCS$`Unequal Var, Single Corr` <- list()#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$correlation  <- tmpr		#
tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	if(K<=2 && !is.null(mr)){#
		tmpm <- mr#
		results$estimates$MMCS$`No Constraints` <- list()#
		results$estimates$MMCS$`No Constraints`$fe.estimates  <-#
			data.frame( Estimate=as.vector(tmpm$b), SE=as.vector(tmpm$se), row.names=xx.col.names )#
		results$estimates$MMCS$`No Constraints`$fe.vcv  <- unname(tmpm$vb)#
		if(K==1){#
			tmpd <- matrix( tmpm$tau2, ncol=K, dimnames=list(udv,ulev) )#
		}else{#
			tmpd <- cbind( tmpm$tau2, tmpm$gamma2 )#
			dimnames(tmpd) <- list(udv, ulev)#
		}#
		results$estimates$MMCS$`No Constraints`$vc$variance  <- data.frame(tmpd)				#
		tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
		tmprr[upper.tri(tmprr)] <- tmpm$rho#
		tmprr <- tmprr + t(tmprr)#
		diag(tmprr) <- 1#
		if(K==1){#
			results$estimates$MMCS$`No Constraints`$vc[[2]]  <- data.frame(tmprr)#
		}else{#
			results$estimates$MMCS$`No Constraints`$vc[[2]]  <- data.frame(tmprr)					#
			tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
			tmprr[upper.tri(tmprr)] <- tmpm$phi#
			tmprr <- tmprr + t(tmprr)#
			diag(tmprr) <- 1#
			results$estimates$MMCS$`No Constraints`$vc[[3]]  <- data.frame(tmprr)					#
		}#
		names(results$estimates$MMCS$`No Constraints`$vc)[-1] <- paste0("correlation.",ulev)#
	}#
	if(K>2 && !is.null(mr)){#
		tmpm <- mr#
		results$estimates$MMCS$`No Constraints` <- list()#
		results$estimates$MMCS$`No Constraints`$fe.estimates  <-#
			data.frame( Estimate=as.vector(tmpm$b), SE=as.vector(tmpm$se), row.names=xx.col.names )#
		results$estimates$MMCS$`No Constraints`$fe.vcv  <- unname(tmpm$vb)#
		tmpd <- matrix( tmpm$sigma2, ncol=K, dimnames=list(udv,ulev) )#
		results$estimates$MMCS$`No Constraints`$vc$variance  <- data.frame(tmpd)#
		tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
		tmprr[upper.tri(tmprr)] <- tmpm$rho#
		tmprr <- tmprr + t(tmprr)#
		diag(tmprr) <- 1#
		for(i in 1:K){ results$estimates$MMCS$`No Constraints`$vc[[i+1]] <- data.frame(tmprr) }#
		names(results$estimates$MMCS$`No Constraints`$vc)[-1] <- paste0("correlation.", ulev)#
	}#
}#
if(!is.null(mr.ea)){#
	tmpm <- mr.ea#
	tmpvc <- convert.theta.ea.nc.custom( tmpm$theta, mv.ml.id, 1E-08, corr.ind )#
	results$estimates$EAMMCS$`No Constraints` <- list()#
	results$estimates$EAMMCS$`No Constraints`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$EAMMCS$`No Constraints`$fe.vcv  <- tmpm$covariance#
	results$estimates$EAMMCS$`No Constraints`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
	results$estimates$EAMMCS$`No Constraints`$vc$allocation  <-#
		data.frame( allocation=tmpvc[[3]], row.names=ulev )#
	tmprr <- tmpvc[[4]]#
	tmprr[upper.tri(tmprr,diag=TRUE)] <- 0#
	tmprr <- tmprr + t(tmprr)#
	diag(tmprr) <- 1#
	dimnames(tmprr) <- list(udv, udv)#
	results$estimates$EAMMCS$`No Constraints`$vc$correlation  <- data.frame(tmprr)#
	tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
	for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
	results$estimates$EAMMCS$`No Constraints`$vc$implied.variance <- data.frame(tmpd)#
	results$estimates$EAMMCS$`No Constraints`$vc$implied.vcv <- tmpvc[[1]]#
}			#
#
#incProgress(1/10)#
results
dat1 <- read.csv("mydata-02.25.22.csv", header=TRUE)#
dat2 <- NULL#
eammcs_only <- FALSE#
# If no dat2: 		dat2 <- NULL#
dat1 <- dat1[dat1$DependentVariable!="Behavior",]
range(dat1$v)
dat1 <- read.csv("mydata-02.25.22.csv", header=TRUE)#
dat2 <- NULL#
eammcs_only <- FALSE#
# If no dat2: 		dat2 <- NULL
dat1[dat1$v==0,]
dat1[dat1$DependentVariable=="Behavior",]
dat1 <- read.csv("mydata-02.25.22.csv", header=TRUE)#
dat2 <- NULL#
eammcs_only <- FALSE#
# If no dat2: 		dat2 <- NULL#
#
dim(dat1)#
dat1 <- dat1[dat1$DependentVariable!="Behavior" | dat$v==0,]#
dim(dat1)
dat1 <- read.csv("mydata-02.25.22.csv", header=TRUE)#
dat2 <- NULL#
eammcs_only <- FALSE#
# If no dat2: 		dat2 <- NULL#
#
dim(dat1)#
dat1 <- dat1[dat1$DependentVariable!="Behavior" | dat1$v==0,]#
dim(dat1)
dat1 <- read.csv("mydata-02.25.22.csv", header=TRUE)#
dat2 <- NULL#
eammcs_only <- FALSE#
# If no dat2: 		dat2 <- NULL#
#
dim(dat1)#
dat1 <- dat1[dat1$DependentVariable!="Behavior" & dat1$v > 0,]#
dim(dat1)
library(metafor)#
source("aux.general.D.R")#
source("aux.reml.aux.blup.optim.option.R")#
results <- messages <- list()#
#
date()#
#
# Error checking I:#
if(is.null(dat1)){ return("Error: No main input data provided.") }#
if(any(is.na(dat1))){ return("Error: No NAs allowed in main input data.") }#
if(ncol(dat1) < 4){ return("Error: Main input data has less than four columns. It must have at minimum four columns.") }#
if(!is.null(dat2)){#
	if(any(is.na(dat2))){ return("Error: No NAs allowed in error variance covariance matrix.") }#
	if(nrow(dat1)!=nrow(dat2)){ return("Error: Main input data and error variance covariance matrix have a different number of rows.") }#
	if(nrow(dat2)!=ncol(dat2)){ return("Error: The error variance covariance matrix must be square.") }#
	Sigma.y <- as.matrix(dat2)#
	M <- max(abs( Sigma.y - t(Sigma.y) ))#
	if(M > 1E-08){ return("Error: The error variance covariance matrix must be symmetric.") }#
	m <- min(eigen(Sigma.y,only.values=TRUE)$values)#
	if(m < 1E-08){ return("Error: The error variance covariance matrix must be positive definite.") }#
	M <- max(abs( diag(Sigma.y) - dat1$v ))#
	if(M > 1E-08){ messages[[length(messages)+1]] <- paste0("Note: The diagonal of the error ",   #
		"variance covariance matrix and the v column of the main input data do not match. As always ",#
		"when an error variance covariance matrix is provided, using the error variance covariance ",#
		"matrix and ignoring the v column of the main input data.") }#
}else{#
	Sigma.y <- diag(dat1$v)#
}#
#
# Error checking II:#
idx1 <- which(colnames(dat1)=="ConditionDescription")#
idx2 <- which(colnames(dat1)=="DependentVariable")#
idx3 <- which(colnames(dat1)=="y")#
idx4 <- which(colnames(dat1)=="v")#
if(idx1!=1){ return("Error: First column of main input data must be ConditionDescription.") }#
if(idx2!=2){ return("Error: Second column of main input data must be DependentVariable.") }#
if(idx4!=(idx3+1)){ return("Error: Column v of main input data must immediately follow column y.") }#
if(!all( c(idx1,idx2,idx3,idx4)==sort(c(idx1,idx2,idx3,idx4)) )){#
	return("Error: Columns of main input data are not properly ordered.") }#
if(idx3==3){#
	messages[[length(messages)+1]] <- "Note: No levels entered. Using the observation as the sole hierarchical level."#
	dat1 <- data.frame( dat1[,1:2], ObsID=1:nrow(dat1), dat1[,-(1:2)] )#
	idx3 <- idx3+1#
	idx4 <- idx4+1#
}#
#
# Group Index Checking I: Checking for duplicate group ID variables#
mv.ml.id <- dat1[,idx2:(idx3-1),drop=FALSE]#
if(ncol(mv.ml.id) > 2){#
	drop.idx <- NULL#
	for(j1 in 3:ncol(mv.ml.id)){#
		for(j2 in 2:(j1-1)){#
			tmpt <- table(mv.ml.id[,j2], mv.ml.id[,j1])#
			tmpr <- rowSums(tmpt>0)#
			tmpc <- colSums(tmpt>0)#
			if(all(tmpr==1) & all(tmpc==1)){ #
				drop.idx <- c(drop.idx, j1)#
				tmpnj1 <- colnames(mv.ml.id)[j1]#
				tmpnj2 <- colnames(mv.ml.id)[j2]#
				messages[[length(messages)+1]] <-  #
					paste0("Note: The group ID variables ",	tmpnj2, " and ", tmpnj1,#
							" give identical groupings. Ignoring ", tmpnj1, ".")#
			}	#
		}#
	}#
	if(!is.null(drop.idx)){ mv.ml.id <- mv.ml.id[,-drop.idx,drop=FALSE] }#
}#
#
# Group Index Checking II: Checking for inner group index with values across #
# multiple outer group index values and giving a warning#
if(ncol(mv.ml.id) > 2){#
	for(i in 2:(ncol(mv.ml.id)-1)){#
		for(j in (i+1):ncol(mv.ml.id)){#
			tmpt <- table(mv.ml.id[,i], mv.ml.id[,j])#
			tmpc <- colSums(tmpt>0)#
			if(any(tmpc > 1)){#
				tmpni <- colnames(mv.ml.id)[i]#
				tmpnj <- colnames(mv.ml.id)[j]#
				messages[[length(messages)+1]] <-  #
					paste0("Note: One or more values of the inner group ID variable ", tmpnj,#
					" appears in more than one value of the outer group ID variable ", tmpni, ".")#
			}			#
		}#
	}#
}#
#
# Build variables#
y <- dat1$y#
dat1$DependentVariable <- as.factor(as.character(dat1$DependentVariable))#
dat1$ConditionDescription <- as.factor(as.character(dat1$ConditionDescription))#
for(i in 1:ncol(mv.ml.id)){ mv.ml.id[,i] <- as.factor(as.character(mv.ml.id[,i])) }#
dumb.vector <- rep(1,length(y))#
#
udv <- levels(dat1$DependentVariable)#
ucond <- levels(dat1$ConditionDescription)#
ulev <- colnames(mv.ml.id)[-1]#
D <- length(unique(mv.ml.id[,1]))		# Number of DVs#
K <- ncol(mv.ml.id) - 1					# Number of Hierarchical Levels (thus K in the code is one less than the K in the manuscript)#
#
# Build standard X matrix#
dv.cond <- as.factor(paste(dat1$DependentVariable, dat1$ConditionDescription, sep=" * "))#
u.dv.cond <- levels(dv.cond)#
X <- matrix(0, length(y), length(u.dv.cond))#
for(i in 1:length(u.dv.cond)){#
	sel <- dv.cond==u.dv.cond[i]#
	X[sel,i] <- 1#
}#
tmp <- which(colSums(X) > 0)#
X <- X[,tmp,drop=FALSE]#
xx.col.names <- u.dv.cond[tmp]#
#
# Add covariates to X#
X1 <- X#
if(ncol(dat1) > idx4){#
	covariate.matrix <- as.matrix( dat1[,(idx4+1):ncol(dat1),drop=FALSE] )#
	for(i in 1:ncol(covariate.matrix)){#
		tmpX <- X * covariate.matrix[,i]#
		tmp <- which(apply(tmpX, 2, sd) > 0)  #
		tmpX <- tmpX[,tmp]#
		X <- cbind(X, tmpX)#
		xx.col.names <- c(xx.col.names, paste(xx.col.names[tmp], colnames(covariate.matrix)[i], sep=" * "))#
	}#
}#
if(ncol(X) > nrow(X)){ return("Error: There are more covariates than rows of data. Reduce the number of covariates.") }#
#
# Set up model evaluation matrices#
reml.ll <- num.param <- matrix(NA, 6, 2)#
colnames(reml.ll) <- colnames(num.param) <- c("MMCS", "EAMMCS")#
rownames(reml.ll) <- rownames(num.param) <- #
	c("Fixed Effects", "Equal Var, Zero Corr", "Equal Var, Single Corr", "Unequal Var, Zero Corr", "Unequal Var, Single Corr", "No Constraints")#
num.param[1,] <- c(0,0)#
num.param[2,] <- c(K,K)#
num.param[3,1] <- K + K*(D>1)#
num.param[3,2] <- K + 1*(D>1)#
num.param[4,1] <- D*K#
num.param[4,2] <- D+K-1#
num.param[5,1] <- D*K + K*(D>1)#
num.param[5,2] <- D+K-1 + 1*(D>1)#
if(eammcs_only){ num.param[,1] <- NA }#
#
# Set up metafor random effects calls#
r.dv.k <- r.k <- list(NULL)#
for(i in 2:ncol(mv.ml.id)){#
	tmps <- paste("~1 | paste(mv.ml.id[, 1], mv.ml.id[, ", i, "], sep = ' - ')", sep="")#
	r.dv.k[[i-1]] <- as.formula(tmps)#
	tmps <- paste("~1 | mv.ml.id[sel, ", i, "]", sep="")#
	r.k[[i-1]] <- as.formula(tmps)#
}#
#
# Fit EAMMCS Fixed Effect Model#
mr.fe <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz.fe, R=Sigma.y, blup=FALSE, eval=TRUE, theta.init=NA)#
#incProgress(0.5/10)
# Fit EAMMCS Equal Variance, Zero Correlation Model#
system.time({ #
tmpm1 <- tmpm2 <- NULL#
try( tmpm1 <- rma.uni(y, diag(Sigma.y), mods=~X-1) )#
try( tmpm2 <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", random=r.dv.k, control=list(maxit=10000)) )#
tmp.init <- rep(0,K)#
if(!is.null(tmpm1)){ tmp.init <- c( log(sqrt( max(tmpm1$tau2,1E-04) )), rep(0,K-1) ) }#
if(!is.null(tmpm2)){#
	if(K==1){ tmp.init <- log(sqrt( max(sum(tmpm2$sigma2),1E-08) ))#
	}else{#
		tmp.init0 <- log(sqrt( max(sum(tmpm2$sigma2),1E-08) ))#
		tmp.init1 <- log(tmpm2$sigma2[1:(K-1)]/tmpm2$sigma2[K])#
		tmp.init1[tmp.init1==Inf] <- 10#
		tmp.init <- c(tmp.init0, tmp.init1)#
	}#
	mr.ea.equalvar.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)	#
}else{#
	mr.ea.equalvar.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.zerocorr, blup=FALSE, eps=1E-08)	#
}#
})#
#incProgress(0.5/10)#
#
# Fit EAMMCS Equal Variance, Single Correlation Model#
if(D==1){ #
	tmp.init <- c(mr.ea.equalvar.zerocorr$theta[1], NA, mr.ea.equalvar.zerocorr$theta[-1])#
	mr.ea.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmp.init <- c( mr.ea.equalvar.zerocorr$theta[1], -3, mr.ea.equalvar.zerocorr$theta[-1] )#
	mr.ea.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.onecorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Fit EAMMCS Unequal Variance, Zero Correlation Model#
if(D==1){ #
	tmp.init <- mr.ea.equalvar.zerocorr$theta#
	mr.ea.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmpm1 <- tmpm2 <- list(NULL)#
	tmp.init <- c( rep(mr.ea.equalvar.zerocorr$theta[1], D), mr.ea.equalvar.zerocorr$theta[-1] )#
	for(i in 1:length(udv)){#
		tmpm1[[i]] <- tmpm2[[i]] <- NA#
		sel <- mv.ml.id[,1]==udv[i]#
		try( tmpm1[[i]] <- rma.uni(y[sel], diag(Sigma.y)[sel], mods=~X[sel,]-1) )#
		try( tmpm2[[i]] <- rma.mv(y[sel], Sigma.y[sel,sel], mods=~X[sel,]-1, struct="CS", random=r.k, control=list(maxit=10000)) )#
		if(!is.na(tmpm1[[i]])){ tmp.init[i] <- log(sqrt( max(tmpm1[[i]]$tau2,1E-04) )) }#
		if(!is.na(tmpm2[[i]])){ tmp.init[i] <- log(sqrt( max(sum(tmpm2[[i]]$sigma2),1E-04) )) }#
	}#
	mr.ea.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.zerocorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Fit EAMMCS Unequal Variance, Single Correlation Model#
if(D==1){ #
	tmp.init <- c(mr.ea.zerocorr$theta[1], NA, mr.ea.zerocorr$theta[-1])#
	mr.ea.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmp.init <- c( mr.ea.zerocorr$theta[1:D], -3, mr.ea.zerocorr$theta[-(1:D)] )#
	mr.ea.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.onecorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Save results of EAMMCS models#
reml.ll[1,] <- -mr.fe$varcomp.opt$value#
reml.ll[2,] <- -min(tryCatch(mr.ea.equalvar.zerocorr$varcomp.opt$value), tryCatch(mr.ea.equalvar.zerocorr$varcomp.opt$objective))#
reml.ll[3,2] <- -mr.ea.equalvar.onecorr$varcomp.opt$value#
reml.ll[4,2] <-  -min(tryCatch(mr.ea.zerocorr$varcomp.opt$value), tryCatch(mr.ea.zerocorr$varcomp.opt$objective))#
reml.ll[5,2] <- -mr.ea.onecorr$varcomp.opt$value#
if(eammcs_only){ reml.ll[1:2,1] <- NA }#
#
if(!eammcs_only){#
	# Fit MMCS Equal Variance, Single Correlation Model#
	# We force positive correlations even though for K==1 and K==2 we can use metafor to get negative#
	# correlations. Nonetheless, we provide a message noting when a negative correlaion improves fit.#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- c(log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] )))#
		mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.equalvar.onecorr.rma.mv <- mr.equalvar.onecorr <- NULL#
			try( mr.equalvar.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2])) )#
			tmp.init <- mr.ea.equalvar.onecorr$theta#
			mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho>0){#
				if( abs(reml.ll[3,1] - logLik(mr.equalvar.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Equal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho<=0){#
				messages[[length(messages)+1]] <- paste0("K=2 MMCS Equal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML LL improves from ", reml.ll[3,1],#
					" to ", logLik(mr.equalvar.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.equalvar.onecorr.rma.mv <- mr.equalvar.onecorr <- NULL#
			try( mr.equalvar.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && mr.equalvar.onecorr.rma.mv$rho>0 && mr.equalvar.onecorr.rma.mv$phi>0){ #
				tmp.init <- c(log(sqrt(mr.equalvar.onecorr.rma.mv$tau2)),#
							  log(sqrt(mr.equalvar.onecorr.rma.mv$gamma2)),#
							  logit(mr.equalvar.onecorr.rma.mv$rho),#
							  logit(mr.equalvar.onecorr.rma.mv$phi))#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.equalvar.onecorr.rma.mv) || mr.equalvar.onecorr.rma.mv$rho<=0 || mr.equalvar.onecorr.rma.mv$phi<=0){#
				tmp.init.convert <- convert.theta.ea.equalvar.onecorr(mr.ea.equalvar.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt(tmp.init.convert[[2]][1]*tmp.init.convert[[3]])),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.equalvar.onecorr)){#
				reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho>0 && mr.equalvar.onecorr.rma.mv$phi>0){#
				if( abs(reml.ll[3,1] - logLik(mr.equalvar.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Equal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && (mr.equalvar.onecorr.rma.mv$rho<=0 || mr.equalvar.onecorr.rma.mv$phi<=0)){#
				messages[[length(messages)+1]] <- paste0("K=3 MMCS Equal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML  LL improves from ", reml.ll[3,1],#
					" to ", logLik(mr.equalvar.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.equalvar.onecorr(mr.ea.equalvar.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt(tmp.init.convert[[2]][1]*tmp.init.convert[[3]])),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.equalvar.onecorr)){#
					reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
				}#
			})#
		}#
	}#
	#incProgress(1.5/10)#
#
	# Fit MMCS Unequal Variance, Zero Correlation Model#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] ))#
		mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# Confirm equivalence of all three#
			mr.zerocorr.rma.mv <- mr.zerocorr <- NULL#
			try( mr.zerocorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2]), rho=0) )#
			tmp.init <- mr.ea.zerocorr$theta#
			mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
			if(!is.null(mr.zerocorr.rma.mv)){#
				if( abs(reml.ll[4,1] - logLik(mr.zerocorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Unequal Variance, Zero Correlation Error." }#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# Confirm equivalence to metafor#
			mr.zerocorr.rma.mv <- mr.zerocorr <- NULL#
			try( mr.zerocorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3]), rho=0, phi=0) )#
			if(!is.null(mr.zerocorr.rma.mv)){ #
				tmp.init <- log(sqrt(as.vector( t(matrix(c(mr.zerocorr.rma.mv$tau2, mr.zerocorr.rma.mv$gamma2), D, K)) )))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.zerocorr.rma.mv)){#
				tmp.init.convert <- convert.theta.ea.zerocorr(mr.ea.zerocorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- log(sqrt( as.vector(t(outer(tmp.init.convert[[2]], tmp.init.convert[[3]]))) ))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.zerocorr)){#
				reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.zerocorr.rma.mv) & !is.null(mr.zerocorr)){#
				if( abs(reml.ll[4,1] - logLik(mr.zerocorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Unequal Variance, Zero Correlation Error." }#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.zerocorr(mr.ea.zerocorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- log(sqrt( as.vector(t(outer(tmp.init.convert[[2]], tmp.init.convert[[3]]))) ))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.zerocorr)){#
					reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
				}#
			})#
		}	#
	}#
	#incProgress(1/10)#
#
	# Fit MMCS Unequal Variance, Single Correlation Model#
	# We force positive correlations even though for K==1 and K==2 we can use metafor to get negative#
	# correlations. Nonetheless, we provide a message noting when a negative correlaion improves fit.#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- c(log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] )))#
		mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# Confirm equivalence of all three#
			mr.onecorr.rma.mv <- mr.onecorr <- NULL#
			try( mr.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2])) )#
			tmp.init <- mr.ea.onecorr$theta#
			mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho>0){#
				if( abs(reml.ll[5,1] - logLik(mr.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Unequal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho<=0){#
				messages[[length(messages)+1]] <- paste0("K=2 MMCS Unequal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML LL improves from ", reml.ll[5,1],#
					" to ", logLik(mr.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.onecorr.rma.mv <- mr.onecorr <- NULL#
			try( mr.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
			if(!is.null(mr.onecorr.rma.mv) && mr.onecorr.rma.mv$rho>0 && mr.onecorr.rma.mv$phi>0){ #
				tmp.init <- c(log(sqrt(mr.onecorr.rma.mv$tau2)),#
							  log(sqrt(mr.onecorr.rma.mv$gamma2)),#
							  logit(mr.onecorr.rma.mv$rho),#
							  logit(mr.onecorr.rma.mv$phi))#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.onecorr.rma.mv) || mr.onecorr.rma.mv$rho<=0 || mr.onecorr.rma.mv$phi<=0){#
				tmp.init.convert <- convert.theta.ea.onecorr(mr.ea.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt( as.vector(outer(tmp.init.convert[[2]], tmp.init.convert[[3]])) )),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.onecorr)){#
				reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho>0 && mr.onecorr.rma.mv$phi>0){#
				if( abs(reml.ll[5,1] - logLik(mr.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Unequal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && (mr.onecorr.rma.mv$rho<=0 || mr.onecorr.rma.mv$phi<=0)){#
				messages[[length(messages)+1]] <- paste0("K=3 MMCS Unequal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML  LL improves from ", reml.ll[5,1],#
					" to ", logLik(mr.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.onecorr(mr.ea.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt( as.vector(outer(tmp.init.convert[[2]], tmp.init.convert[[3]])) )),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.onecorr)){#
					reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
				}#
			})#
		}#
	}#
	#incProgress(1.5/10)#
}else{#
	#incProgress(4/10)#
}#
#
# Fit additional models for K==1 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K==1){#
	system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# However, with No Constraints metafor allows negative correlations while we force positive#
			# correlations so we will fit both#
#
			# MMCS No Constraint#
			mr <- NULL#
			try( mr <- rma.mv(y, Sigma.y, mods=~X-1, struct="UN", control=list(maxit=10000),#
										random=~mv.ml.id[,1]|mv.ml.id[,2]) )#
			if(!is.null(mr) & !eammcs_only){ #
				num.param[6,1] <- sum( unlist(mr$vc.fix)==FALSE, na.rm=TRUE )#
				reml.ll[6,1] <- logLik(mr)#
			}#
	})#
#
	# EAMMCS No Constraint - If all MMCS No Constraint correlations are positive this is #
	# the same model so we will simply evaluate (rather than maximize it) using our code.#
	# But, if all MMCS No Constraint correlations are NOT positive this is we must maximize#
	# using our code#
	mr.ea <- NULL#
	if(D==1){ mr.ea <- mr.ea.equalvar.zerocorr; corr.ind <- numeric(0) }#
	system.time({ if(D!=1 & !is.null(mr) & all(mr$rho >= 0)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- logit(pmin(pmax(mr$rho,1E-08),1-1E-08))#
		tmp <- upper.tri.vec.to.lower.tri.vec(tmp)[corr.ind==1]#
		tmp.init <- c(log(sqrt( pmax(mr$tau2,1E-08) )), tmp)#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eval=TRUE, eps=1E-08) )#
		if(!is.null(mr.ea)){#
			if(abs(-mr.ea$varcomp.opt$value - logLik(mr)) > 1E-04){ #
				messages[[length(messages)+1]] <- "Error: K=2 EAMMCS No Constraint Error." }#
		}	#
	} })#
	system.time({ if(D!=1 & !is.null(mr) & !all(mr$rho >= 0)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- mr.ea.onecorr$theta[D+1]#
		tmp.init <- c(mr.ea.onecorr$theta[1:D], rep(tmp,sum(corr.ind)), mr.ea.onecorr$theta[-(1:(D+1))])#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eps=1E-08) )#
	} })#
	if(!is.null(mr.ea)){#
		num.param[6,2] <- length(mr.ea$theta)#
		reml.ll[6,2] <- -mr.ea$varcomp.opt$value#
	}	#
}#
#
# Fit additional models for K==2 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K==2){#
	system.time({#
		# MMCS No Constraint#
		mr <- NULL#
		try( mr <- rma.mv(y, Sigma.y, mods=~X-1, struct="UN", control=list(maxit=10000),#
								random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
		if(!is.null(mr) & !eammcs_only){ #
			num.param[6,1] <- sum( unlist(mr$vc.fix)==FALSE, na.rm=TRUE ) #
			reml.ll[6,1] <- logLik(mr)#
		}#
	})#
#
	# EAMMCS No Constraint#
	mr.ea <- NULL#
	if(D==1){ mr.ea <- mr.ea.equalvar.zerocorr; corr.ind <- numeric(0)#
	}else{	#
	system.time({ if(!is.null(mr)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE | mr$vc.fix$phi==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- mr.ea.onecorr$theta[D+1]#
		tmp.init <- c(mr.ea.onecorr$theta[1:D], rep(tmp,sum(corr.ind)), mr.ea.onecorr$theta[-(1:(D+1))])#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eval=(D==2), eps=1E-08) )#
	}})}#
	if(!is.null(mr.ea)){#
		num.param[6,2] <- length(mr.ea$theta)#
		reml.ll[6,2] <- -mr.ea$varcomp.opt$value#
	}#
}#
#
# "Fit" additional models for K>2 & D==1 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K>2 & D==1){#
	# When D==1, all models are equivalent to one another (except fixed effects, which differs obviously)#
	if(is.null(tmpm2)){#
		messages[[length(messages)+1]] <- "Error: K>2, D==1 model error."#
		tmpv <- exp(mr.ea.equalvar.zerocorr$theta[1])^2#
		tmpf <- c(mr.ea.equalvar.zerocorr$theta[-1],0)#
		tmpf <- exp(tmpf)/sum(exp(tmpf))#
		tmpm2 <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", random=r.dv.k, sigma2=tmpv*tmpf)#
	}#
#
	if(!eammcs_only){#
		mr <- tmpm2#
		reml.ll[6,1] <- logLik(mr)#
		num.param[6,1] <- K#
	}#
#
	mr.ea <- mr.ea.equalvar.zerocorr#
	corr.ind <- numeric(0)#
	reml.ll[6,2] <- -mr.ea.equalvar.zerocorr$varcomp.opt$value#
	num.param[6,2] <- K	#
}#
if(K>2 & D>1){ mr <- mr.ea <- NULL } #
#incProgress(1/10)#
#
# Store log likelihood results#
results$K <- K+1#
results$D <- D#
results$REML.LL <- reml.ll#
results$Number.of.Variance.Component.Parameters <- num.param#
results$AIC <- 2*num.param - 2*reml.ll#
results$messages <- messages#
#
# Store estimates#
results$estimates <- list()#
if(!eammcs_only){ results$estimates$MMCS <- list() }#
results$estimates$EAMMCS <- list()#
tmpm <- mr.fe#
if(!eammcs_only){#
	results$estimates$MMCS$`Fixed Effects` <- list()#
	results$estimates$MMCS$`Fixed Effects`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Fixed Effects`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Fixed Effects`$vc  <- NA#
}#
tmpm <- mr.fe  # Equivalent to mr.ea.fe#
results$estimates$EAMMCS$`Fixed Effects` <- list()#
results$estimates$EAMMCS$`Fixed Effects`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Fixed Effects`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Fixed Effects`$vc  <- NA#
if(!eammcs_only){#
	tmpm <- mr.ea.equalvar.zerocorr  # Equivalent to mr.equalvar.zerocorr#
	tmpvc <- convert.theta.ea.equalvar.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Equal Var, Zero Corr` <- list()#
	results$estimates$MMCS$`Equal Var, Zero Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Equal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
	tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
	results$estimates$MMCS$`Equal Var, Zero Corr`$vc$variance  <- data.frame(tmpd)#
}#
tmpm <- mr.ea.equalvar.zerocorr#
tmpvc <- convert.theta.ea.equalvar.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
results$estimates$EAMMCS$`Equal Var, Zero Corr` <- list()#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$variance  <- tmpvc[[2]][1]#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.equalvar.onecorr#
	tmpvc <- convert.theta.equalvar.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Equal Var, Single Corr` <- list()#
	results$estimates$MMCS$`Equal Var, Single Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Equal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Equal Var, Single Corr`$vc$variance  <- apply(tmpvc[[1]], 3, function(x){x[1,1]})#
	if(D==1){#
		tmpcorr <- results$estimates$MMCS$`Equal Var, Single Corr`$vc$variance#
		tmpcorr[1:K] <- NA#
		results$estimates$MMCS$`Equal Var, Single Corr`$vc$correlation <- tmpcorr#
	}else{#
		results$estimates$MMCS$`Equal Var, Single Corr`$vc$correlation  <- apply(tmpvc[[1]], 3, function(x){cov2cor(x)[2,1]})#
	}		#
}#
tmpm <- mr.ea.equalvar.onecorr#
tmpvc <- convert.theta.ea.equalvar.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
tmpr <- ifelse(D==1, NA, unique(as.vector(tmpvc[[4]][ !is.na(tmpvc[[4]]) ])))#
results$estimates$EAMMCS$`Equal Var, Single Corr` <- list()#
results$estimates$EAMMCS$`Equal Var, Single Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$variance  <- tmpvc[[2]][1]#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$correlation  <- tmpr		#
tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.zerocorr#
	tmpvc <- convert.theta.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Unequal Var, Zero Corr` <- list()#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$vc$variance  <- apply(tmpvc[[1]], 3, diag)#
}#
tmpm <- mr.ea.zerocorr#
tmpvc <- convert.theta.ea.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
results$estimates$EAMMCS$`Unequal Var, Zero Corr` <- list()#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.onecorr#
	tmpvc <- convert.theta.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Unequal Var, Single Corr` <- list()#
	results$estimates$MMCS$`Unequal Var, Single Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Unequal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Unequal Var, Single Corr`$vc$variance  <- apply(tmpvc[[1]], 3, diag)#
	if(D==1){#
		tmpcorr <- results$estimates$MMCS$`Unequal Var, Single Corr`$vc$variance#
		tmpcorr[1:K] <- NA#
		results$estimates$MMCS$`Unequal Var, Single Corr`$vc$correlation <- tmpcorr#
	}else{#
		results$estimates$MMCS$`Unequal Var, Single Corr`$vc$correlation  <- apply(tmpvc[[1]], 3, function(x){cov2cor(x)[2,1]})#
	}#
}#
tmpm <- mr.ea.onecorr#
tmpvc <- convert.theta.ea.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
tmpr <- ifelse(D==1, NA, unique(as.vector(tmpvc[[4]][ !is.na(tmpvc[[4]]) ])))#
results$estimates$EAMMCS$`Unequal Var, Single Corr` <- list()#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$correlation  <- tmpr		#
tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	if(K<=2 && !is.null(mr)){#
		tmpm <- mr#
		results$estimates$MMCS$`No Constraints` <- list()#
		results$estimates$MMCS$`No Constraints`$fe.estimates  <-#
			data.frame( Estimate=as.vector(tmpm$b), SE=as.vector(tmpm$se), row.names=xx.col.names )#
		results$estimates$MMCS$`No Constraints`$fe.vcv  <- unname(tmpm$vb)#
		if(K==1){#
			tmpd <- matrix( tmpm$tau2, ncol=K, dimnames=list(udv,ulev) )#
		}else{#
			tmpd <- cbind( tmpm$tau2, tmpm$gamma2 )#
			dimnames(tmpd) <- list(udv, ulev)#
		}#
		results$estimates$MMCS$`No Constraints`$vc$variance  <- data.frame(tmpd)				#
		tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
		tmprr[upper.tri(tmprr)] <- tmpm$rho#
		tmprr <- tmprr + t(tmprr)#
		diag(tmprr) <- 1#
		if(K==1){#
			results$estimates$MMCS$`No Constraints`$vc[[2]]  <- data.frame(tmprr)#
		}else{#
			results$estimates$MMCS$`No Constraints`$vc[[2]]  <- data.frame(tmprr)					#
			tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
			tmprr[upper.tri(tmprr)] <- tmpm$phi#
			tmprr <- tmprr + t(tmprr)#
			diag(tmprr) <- 1#
			results$estimates$MMCS$`No Constraints`$vc[[3]]  <- data.frame(tmprr)					#
		}#
		names(results$estimates$MMCS$`No Constraints`$vc)[-1] <- paste0("correlation.",ulev)#
	}#
	if(K>2 && !is.null(mr)){#
		tmpm <- mr#
		results$estimates$MMCS$`No Constraints` <- list()#
		results$estimates$MMCS$`No Constraints`$fe.estimates  <-#
			data.frame( Estimate=as.vector(tmpm$b), SE=as.vector(tmpm$se), row.names=xx.col.names )#
		results$estimates$MMCS$`No Constraints`$fe.vcv  <- unname(tmpm$vb)#
		tmpd <- matrix( tmpm$sigma2, ncol=K, dimnames=list(udv,ulev) )#
		results$estimates$MMCS$`No Constraints`$vc$variance  <- data.frame(tmpd)#
		tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
		tmprr[upper.tri(tmprr)] <- tmpm$rho#
		tmprr <- tmprr + t(tmprr)#
		diag(tmprr) <- 1#
		for(i in 1:K){ results$estimates$MMCS$`No Constraints`$vc[[i+1]] <- data.frame(tmprr) }#
		names(results$estimates$MMCS$`No Constraints`$vc)[-1] <- paste0("correlation.", ulev)#
	}#
}#
if(!is.null(mr.ea)){#
	tmpm <- mr.ea#
	tmpvc <- convert.theta.ea.nc.custom( tmpm$theta, mv.ml.id, 1E-08, corr.ind )#
	results$estimates$EAMMCS$`No Constraints` <- list()#
	results$estimates$EAMMCS$`No Constraints`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$EAMMCS$`No Constraints`$fe.vcv  <- tmpm$covariance#
	results$estimates$EAMMCS$`No Constraints`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
	results$estimates$EAMMCS$`No Constraints`$vc$allocation  <-#
		data.frame( allocation=tmpvc[[3]], row.names=ulev )#
	tmprr <- tmpvc[[4]]#
	tmprr[upper.tri(tmprr,diag=TRUE)] <- 0#
	tmprr <- tmprr + t(tmprr)#
	diag(tmprr) <- 1#
	dimnames(tmprr) <- list(udv, udv)#
	results$estimates$EAMMCS$`No Constraints`$vc$correlation  <- data.frame(tmprr)#
	tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
	for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
	results$estimates$EAMMCS$`No Constraints`$vc$implied.variance <- data.frame(tmpd)#
	results$estimates$EAMMCS$`No Constraints`$vc$implied.vcv <- tmpvc[[1]]#
}			#
#
#incProgress(1/10)#
results#
#
date()
?save
getwd()
a <- rnorm(10000)
save(a, file="results.Rdata")
dat1 <- read.csv("case2.main.csv", header=TRUE)#
dat2 <- NULL#
eammcs_only <- FALSE#
# If no dat2: 		dat2 <- NULL#
library(metafor)#
source("aux.general.D.R")#
source("aux.reml.aux.blup.optim.option.R")#
results <- messages <- list()#
#
date()#
#
# Error checking I:#
if(is.null(dat1)){ return("Error: No main input data provided.") }#
if(any(is.na(dat1))){ return("Error: No NAs allowed in main input data.") }#
if(ncol(dat1) < 4){ return("Error: Main input data has less than four columns. It must have at minimum four columns.") }#
if(!is.null(dat2)){#
	if(any(is.na(dat2))){ return("Error: No NAs allowed in error variance covariance matrix.") }#
	if(nrow(dat1)!=nrow(dat2)){ return("Error: Main input data and error variance covariance matrix have a different number of rows.") }#
	if(nrow(dat2)!=ncol(dat2)){ return("Error: The error variance covariance matrix must be square.") }#
	Sigma.y <- as.matrix(dat2)#
	M <- max(abs( Sigma.y - t(Sigma.y) ))#
	if(M > 1E-08){ return("Error: The error variance covariance matrix must be symmetric.") }#
	m <- min(eigen(Sigma.y,only.values=TRUE)$values)#
	if(m < 1E-08){ return("Error: The error variance covariance matrix must be positive definite.") }#
	M <- max(abs( diag(Sigma.y) - dat1$v ))#
	if(M > 1E-08){ messages[[length(messages)+1]] <- paste0("Note: The diagonal of the error ",   #
		"variance covariance matrix and the v column of the main input data do not match. As always ",#
		"when an error variance covariance matrix is provided, using the error variance covariance ",#
		"matrix and ignoring the v column of the main input data.") }#
}else{#
	Sigma.y <- diag(dat1$v)#
}#
#
# Error checking II:#
idx1 <- which(colnames(dat1)=="ConditionDescription")#
idx2 <- which(colnames(dat1)=="DependentVariable")#
idx3 <- which(colnames(dat1)=="y")#
idx4 <- which(colnames(dat1)=="v")#
if(idx1!=1){ return("Error: First column of main input data must be ConditionDescription.") }#
if(idx2!=2){ return("Error: Second column of main input data must be DependentVariable.") }#
if(idx4!=(idx3+1)){ return("Error: Column v of main input data must immediately follow column y.") }#
if(!all( c(idx1,idx2,idx3,idx4)==sort(c(idx1,idx2,idx3,idx4)) )){#
	return("Error: Columns of main input data are not properly ordered.") }#
if(idx3==3){#
	messages[[length(messages)+1]] <- "Note: No levels entered. Using the observation as the sole hierarchical level."#
	dat1 <- data.frame( dat1[,1:2], ObsID=1:nrow(dat1), dat1[,-(1:2)] )#
	idx3 <- idx3+1#
	idx4 <- idx4+1#
}#
#
# Group Index Checking I: Checking for duplicate group ID variables#
mv.ml.id <- dat1[,idx2:(idx3-1),drop=FALSE]#
if(ncol(mv.ml.id) > 2){#
	drop.idx <- NULL#
	for(j1 in 3:ncol(mv.ml.id)){#
		for(j2 in 2:(j1-1)){#
			tmpt <- table(mv.ml.id[,j2], mv.ml.id[,j1])#
			tmpr <- rowSums(tmpt>0)#
			tmpc <- colSums(tmpt>0)#
			if(all(tmpr==1) & all(tmpc==1)){ #
				drop.idx <- c(drop.idx, j1)#
				tmpnj1 <- colnames(mv.ml.id)[j1]#
				tmpnj2 <- colnames(mv.ml.id)[j2]#
				messages[[length(messages)+1]] <-  #
					paste0("Note: The group ID variables ",	tmpnj2, " and ", tmpnj1,#
							" give identical groupings. Ignoring ", tmpnj1, ".")#
			}	#
		}#
	}#
	if(!is.null(drop.idx)){ mv.ml.id <- mv.ml.id[,-drop.idx,drop=FALSE] }#
}#
#
# Group Index Checking II: Checking for inner group index with values across #
# multiple outer group index values and giving a warning#
if(ncol(mv.ml.id) > 2){#
	for(i in 2:(ncol(mv.ml.id)-1)){#
		for(j in (i+1):ncol(mv.ml.id)){#
			tmpt <- table(mv.ml.id[,i], mv.ml.id[,j])#
			tmpc <- colSums(tmpt>0)#
			if(any(tmpc > 1)){#
				tmpni <- colnames(mv.ml.id)[i]#
				tmpnj <- colnames(mv.ml.id)[j]#
				messages[[length(messages)+1]] <-  #
					paste0("Note: One or more values of the inner group ID variable ", tmpnj,#
					" appears in more than one value of the outer group ID variable ", tmpni, ".")#
			}			#
		}#
	}#
}#
#
# Build variables#
y <- dat1$y#
dat1$DependentVariable <- as.factor(as.character(dat1$DependentVariable))#
dat1$ConditionDescription <- as.factor(as.character(dat1$ConditionDescription))#
for(i in 1:ncol(mv.ml.id)){ mv.ml.id[,i] <- as.factor(as.character(mv.ml.id[,i])) }#
dumb.vector <- rep(1,length(y))#
#
udv <- levels(dat1$DependentVariable)#
ucond <- levels(dat1$ConditionDescription)#
ulev <- colnames(mv.ml.id)[-1]#
D <- length(unique(mv.ml.id[,1]))		# Number of DVs#
K <- ncol(mv.ml.id) - 1					# Number of Hierarchical Levels (thus K in the code is one less than the K in the manuscript)#
#
# Build standard X matrix#
dv.cond <- as.factor(paste(dat1$DependentVariable, dat1$ConditionDescription, sep=" * "))#
u.dv.cond <- levels(dv.cond)#
X <- matrix(0, length(y), length(u.dv.cond))#
for(i in 1:length(u.dv.cond)){#
	sel <- dv.cond==u.dv.cond[i]#
	X[sel,i] <- 1#
}#
tmp <- which(colSums(X) > 0)#
X <- X[,tmp,drop=FALSE]#
xx.col.names <- u.dv.cond[tmp]#
#
# Add covariates to X#
X1 <- X#
if(ncol(dat1) > idx4){#
	covariate.matrix <- as.matrix( dat1[,(idx4+1):ncol(dat1),drop=FALSE] )#
	for(i in 1:ncol(covariate.matrix)){#
		tmpX <- X * covariate.matrix[,i]#
		tmp <- which(apply(tmpX, 2, sd) > 0)  #
		tmpX <- tmpX[,tmp]#
		X <- cbind(X, tmpX)#
		xx.col.names <- c(xx.col.names, paste(xx.col.names[tmp], colnames(covariate.matrix)[i], sep=" * "))#
	}#
}#
if(ncol(X) > nrow(X)){ return("Error: There are more covariates than rows of data. Reduce the number of covariates.") }#
#
# Set up model evaluation matrices#
reml.ll <- num.param <- matrix(NA, 6, 2)#
colnames(reml.ll) <- colnames(num.param) <- c("MMCS", "EAMMCS")#
rownames(reml.ll) <- rownames(num.param) <- #
	c("Fixed Effects", "Equal Var, Zero Corr", "Equal Var, Single Corr", "Unequal Var, Zero Corr", "Unequal Var, Single Corr", "No Constraints")#
num.param[1,] <- c(0,0)#
num.param[2,] <- c(K,K)#
num.param[3,1] <- K + K*(D>1)#
num.param[3,2] <- K + 1*(D>1)#
num.param[4,1] <- D*K#
num.param[4,2] <- D+K-1#
num.param[5,1] <- D*K + K*(D>1)#
num.param[5,2] <- D+K-1 + 1*(D>1)#
if(eammcs_only){ num.param[,1] <- NA }#
#
# Set up metafor random effects calls#
r.dv.k <- r.k <- list(NULL)#
for(i in 2:ncol(mv.ml.id)){#
	tmps <- paste("~1 | paste(mv.ml.id[, 1], mv.ml.id[, ", i, "], sep = ' - ')", sep="")#
	r.dv.k[[i-1]] <- as.formula(tmps)#
	tmps <- paste("~1 | mv.ml.id[sel, ", i, "]", sep="")#
	r.k[[i-1]] <- as.formula(tmps)#
}#
#
# Fit EAMMCS Fixed Effect Model#
mr.fe <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz.fe, R=Sigma.y, blup=FALSE, eval=TRUE, theta.init=NA)#
#incProgress(0.5/10)#
#
# Fit EAMMCS Equal Variance, Zero Correlation Model#
system.time({ #
tmpm1 <- tmpm2 <- NULL#
try( tmpm1 <- rma.uni(y, diag(Sigma.y), mods=~X-1) )#
try( tmpm2 <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", random=r.dv.k, control=list(maxit=10000)) )#
tmp.init <- rep(0,K)#
if(!is.null(tmpm1)){ tmp.init <- c( log(sqrt( max(tmpm1$tau2,1E-04) )), rep(0,K-1) ) }#
if(!is.null(tmpm2)){#
	if(K==1){ tmp.init <- log(sqrt( max(sum(tmpm2$sigma2),1E-08) ))#
	}else{#
		tmp.init0 <- log(sqrt( max(sum(tmpm2$sigma2),1E-08) ))#
		tmp.init1 <- log(tmpm2$sigma2[1:(K-1)]/tmpm2$sigma2[K])#
		tmp.init1[tmp.init1==Inf] <- 10#
		tmp.init <- c(tmp.init0, tmp.init1)#
	}#
	mr.ea.equalvar.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)	#
}else{#
	mr.ea.equalvar.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.zerocorr, blup=FALSE, eps=1E-08)	#
}#
})#
#incProgress(0.5/10)#
#
# Fit EAMMCS Equal Variance, Single Correlation Model#
if(D==1){ #
	tmp.init <- c(mr.ea.equalvar.zerocorr$theta[1], NA, mr.ea.equalvar.zerocorr$theta[-1])#
	mr.ea.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmp.init <- c( mr.ea.equalvar.zerocorr$theta[1], -3, mr.ea.equalvar.zerocorr$theta[-1] )#
	mr.ea.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.onecorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Fit EAMMCS Unequal Variance, Zero Correlation Model#
if(D==1){ #
	tmp.init <- mr.ea.equalvar.zerocorr$theta#
	mr.ea.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmpm1 <- tmpm2 <- list(NULL)#
	tmp.init <- c( rep(mr.ea.equalvar.zerocorr$theta[1], D), mr.ea.equalvar.zerocorr$theta[-1] )#
	for(i in 1:length(udv)){#
		tmpm1[[i]] <- tmpm2[[i]] <- NA#
		sel <- mv.ml.id[,1]==udv[i]#
		try( tmpm1[[i]] <- rma.uni(y[sel], diag(Sigma.y)[sel], mods=~X[sel,]-1) )#
		try( tmpm2[[i]] <- rma.mv(y[sel], Sigma.y[sel,sel], mods=~X[sel,]-1, struct="CS", random=r.k, control=list(maxit=10000)) )#
		if(!is.na(tmpm1[[i]])){ tmp.init[i] <- log(sqrt( max(tmpm1[[i]]$tau2,1E-04) )) }#
		if(!is.na(tmpm2[[i]])){ tmp.init[i] <- log(sqrt( max(sum(tmpm2[[i]]$sigma2),1E-04) )) }#
	}#
	mr.ea.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.zerocorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Fit EAMMCS Unequal Variance, Single Correlation Model#
if(D==1){ #
	tmp.init <- c(mr.ea.zerocorr$theta[1], NA, mr.ea.zerocorr$theta[-1])#
	mr.ea.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmp.init <- c( mr.ea.zerocorr$theta[1:D], -3, mr.ea.zerocorr$theta[-(1:D)] )#
	mr.ea.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.onecorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Save results of EAMMCS models#
reml.ll[1,] <- -mr.fe$varcomp.opt$value#
reml.ll[2,] <- -min(tryCatch(mr.ea.equalvar.zerocorr$varcomp.opt$value), tryCatch(mr.ea.equalvar.zerocorr$varcomp.opt$objective))#
reml.ll[3,2] <- -mr.ea.equalvar.onecorr$varcomp.opt$value#
reml.ll[4,2] <-  -min(tryCatch(mr.ea.zerocorr$varcomp.opt$value), tryCatch(mr.ea.zerocorr$varcomp.opt$objective))#
reml.ll[5,2] <- -mr.ea.onecorr$varcomp.opt$value#
if(eammcs_only){ reml.ll[1:2,1] <- NA }#
#
if(!eammcs_only){#
	# Fit MMCS Equal Variance, Single Correlation Model#
	# We force positive correlations even though for K==1 and K==2 we can use metafor to get negative#
	# correlations. Nonetheless, we provide a message noting when a negative correlaion improves fit.#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- c(log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] )))#
		mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.equalvar.onecorr.rma.mv <- mr.equalvar.onecorr <- NULL#
			try( mr.equalvar.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2])) )#
			tmp.init <- mr.ea.equalvar.onecorr$theta#
			mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho>0){#
				if( abs(reml.ll[3,1] - logLik(mr.equalvar.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Equal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho<=0){#
				messages[[length(messages)+1]] <- paste0("K=2 MMCS Equal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML LL improves from ", reml.ll[3,1],#
					" to ", logLik(mr.equalvar.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.equalvar.onecorr.rma.mv <- mr.equalvar.onecorr <- NULL#
			try( mr.equalvar.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && mr.equalvar.onecorr.rma.mv$rho>0 && mr.equalvar.onecorr.rma.mv$phi>0){ #
				tmp.init <- c(log(sqrt(mr.equalvar.onecorr.rma.mv$tau2)),#
							  log(sqrt(mr.equalvar.onecorr.rma.mv$gamma2)),#
							  logit(mr.equalvar.onecorr.rma.mv$rho),#
							  logit(mr.equalvar.onecorr.rma.mv$phi))#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.equalvar.onecorr.rma.mv) || mr.equalvar.onecorr.rma.mv$rho<=0 || mr.equalvar.onecorr.rma.mv$phi<=0){#
				tmp.init.convert <- convert.theta.ea.equalvar.onecorr(mr.ea.equalvar.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt(tmp.init.convert[[2]][1]*tmp.init.convert[[3]])),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.equalvar.onecorr)){#
				reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho>0 && mr.equalvar.onecorr.rma.mv$phi>0){#
				if( abs(reml.ll[3,1] - logLik(mr.equalvar.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Equal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && (mr.equalvar.onecorr.rma.mv$rho<=0 || mr.equalvar.onecorr.rma.mv$phi<=0)){#
				messages[[length(messages)+1]] <- paste0("K=3 MMCS Equal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML  LL improves from ", reml.ll[3,1],#
					" to ", logLik(mr.equalvar.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.equalvar.onecorr(mr.ea.equalvar.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt(tmp.init.convert[[2]][1]*tmp.init.convert[[3]])),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.equalvar.onecorr)){#
					reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
				}#
			})#
		}#
	}#
	#incProgress(1.5/10)#
#
	# Fit MMCS Unequal Variance, Zero Correlation Model#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] ))#
		mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# Confirm equivalence of all three#
			mr.zerocorr.rma.mv <- mr.zerocorr <- NULL#
			try( mr.zerocorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2]), rho=0) )#
			tmp.init <- mr.ea.zerocorr$theta#
			mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
			if(!is.null(mr.zerocorr.rma.mv)){#
				if( abs(reml.ll[4,1] - logLik(mr.zerocorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Unequal Variance, Zero Correlation Error." }#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# Confirm equivalence to metafor#
			mr.zerocorr.rma.mv <- mr.zerocorr <- NULL#
			try( mr.zerocorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3]), rho=0, phi=0) )#
			if(!is.null(mr.zerocorr.rma.mv)){ #
				tmp.init <- log(sqrt(as.vector( t(matrix(c(mr.zerocorr.rma.mv$tau2, mr.zerocorr.rma.mv$gamma2), D, K)) )))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.zerocorr.rma.mv)){#
				tmp.init.convert <- convert.theta.ea.zerocorr(mr.ea.zerocorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- log(sqrt( as.vector(t(outer(tmp.init.convert[[2]], tmp.init.convert[[3]]))) ))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.zerocorr)){#
				reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.zerocorr.rma.mv) & !is.null(mr.zerocorr)){#
				if( abs(reml.ll[4,1] - logLik(mr.zerocorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Unequal Variance, Zero Correlation Error." }#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.zerocorr(mr.ea.zerocorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- log(sqrt( as.vector(t(outer(tmp.init.convert[[2]], tmp.init.convert[[3]]))) ))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.zerocorr)){#
					reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
				}#
			})#
		}	#
	}#
	#incProgress(1/10)#
#
	# Fit MMCS Unequal Variance, Single Correlation Model#
	# We force positive correlations even though for K==1 and K==2 we can use metafor to get negative#
	# correlations. Nonetheless, we provide a message noting when a negative correlaion improves fit.#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- c(log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] )))#
		mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# Confirm equivalence of all three#
			mr.onecorr.rma.mv <- mr.onecorr <- NULL#
			try( mr.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2])) )#
			tmp.init <- mr.ea.onecorr$theta#
			mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho>0){#
				if( abs(reml.ll[5,1] - logLik(mr.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Unequal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho<=0){#
				messages[[length(messages)+1]] <- paste0("K=2 MMCS Unequal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML LL improves from ", reml.ll[5,1],#
					" to ", logLik(mr.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.onecorr.rma.mv <- mr.onecorr <- NULL#
			try( mr.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
			if(!is.null(mr.onecorr.rma.mv) && mr.onecorr.rma.mv$rho>0 && mr.onecorr.rma.mv$phi>0){ #
				tmp.init <- c(log(sqrt(mr.onecorr.rma.mv$tau2)),#
							  log(sqrt(mr.onecorr.rma.mv$gamma2)),#
							  logit(mr.onecorr.rma.mv$rho),#
							  logit(mr.onecorr.rma.mv$phi))#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.onecorr.rma.mv) || mr.onecorr.rma.mv$rho<=0 || mr.onecorr.rma.mv$phi<=0){#
				tmp.init.convert <- convert.theta.ea.onecorr(mr.ea.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt( as.vector(outer(tmp.init.convert[[2]], tmp.init.convert[[3]])) )),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.onecorr)){#
				reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho>0 && mr.onecorr.rma.mv$phi>0){#
				if( abs(reml.ll[5,1] - logLik(mr.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Unequal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && (mr.onecorr.rma.mv$rho<=0 || mr.onecorr.rma.mv$phi<=0)){#
				messages[[length(messages)+1]] <- paste0("K=3 MMCS Unequal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML  LL improves from ", reml.ll[5,1],#
					" to ", logLik(mr.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.onecorr(mr.ea.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt( as.vector(outer(tmp.init.convert[[2]], tmp.init.convert[[3]])) )),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.onecorr)){#
					reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
				}#
			})#
		}#
	}#
	#incProgress(1.5/10)#
}else{#
	#incProgress(4/10)#
}#
#
# Fit additional models for K==1 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K==1){#
	system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# However, with No Constraints metafor allows negative correlations while we force positive#
			# correlations so we will fit both#
#
			# MMCS No Constraint#
			mr <- NULL#
			try( mr <- rma.mv(y, Sigma.y, mods=~X-1, struct="UN", control=list(maxit=10000),#
										random=~mv.ml.id[,1]|mv.ml.id[,2]) )#
			if(!is.null(mr) & !eammcs_only){ #
				num.param[6,1] <- sum( unlist(mr$vc.fix)==FALSE, na.rm=TRUE )#
				reml.ll[6,1] <- logLik(mr)#
			}#
	})#
#
	# EAMMCS No Constraint - If all MMCS No Constraint correlations are positive this is #
	# the same model so we will simply evaluate (rather than maximize it) using our code.#
	# But, if all MMCS No Constraint correlations are NOT positive this is we must maximize#
	# using our code#
	mr.ea <- NULL#
	if(D==1){ mr.ea <- mr.ea.equalvar.zerocorr; corr.ind <- numeric(0) }#
	system.time({ if(D!=1 & !is.null(mr) & all(mr$rho >= 0)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- logit(pmin(pmax(mr$rho,1E-08),1-1E-08))#
		tmp <- upper.tri.vec.to.lower.tri.vec(tmp)[corr.ind==1]#
		tmp.init <- c(log(sqrt( pmax(mr$tau2,1E-08) )), tmp)#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eval=TRUE, eps=1E-08) )#
		if(!is.null(mr.ea)){#
			if(abs(-mr.ea$varcomp.opt$value - logLik(mr)) > 1E-04){ #
				messages[[length(messages)+1]] <- "Error: K=2 EAMMCS No Constraint Error." }#
		}	#
	} })#
	system.time({ if(D!=1 & !is.null(mr) & !all(mr$rho >= 0)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- mr.ea.onecorr$theta[D+1]#
		tmp.init <- c(mr.ea.onecorr$theta[1:D], rep(tmp,sum(corr.ind)), mr.ea.onecorr$theta[-(1:(D+1))])#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eps=1E-08) )#
	} })#
	if(!is.null(mr.ea)){#
		num.param[6,2] <- length(mr.ea$theta)#
		reml.ll[6,2] <- -mr.ea$varcomp.opt$value#
	}	#
}#
#
# Fit additional models for K==2 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K==2){#
	system.time({#
		# MMCS No Constraint#
		mr <- NULL#
		try( mr <- rma.mv(y, Sigma.y, mods=~X-1, struct="UN", control=list(maxit=10000),#
								random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
		if(!is.null(mr) & !eammcs_only){ #
			num.param[6,1] <- sum( unlist(mr$vc.fix)==FALSE, na.rm=TRUE ) #
			reml.ll[6,1] <- logLik(mr)#
		}#
	})#
#
	# EAMMCS No Constraint#
	mr.ea <- NULL#
	if(D==1){ mr.ea <- mr.ea.equalvar.zerocorr; corr.ind <- numeric(0)#
	}else{	#
	system.time({ if(!is.null(mr)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE | mr$vc.fix$phi==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- mr.ea.onecorr$theta[D+1]#
		tmp.init <- c(mr.ea.onecorr$theta[1:D], rep(tmp,sum(corr.ind)), mr.ea.onecorr$theta[-(1:(D+1))])#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eval=(D==2), eps=1E-08) )#
	}})}#
	if(!is.null(mr.ea)){#
		num.param[6,2] <- length(mr.ea$theta)#
		reml.ll[6,2] <- -mr.ea$varcomp.opt$value#
	}#
}#
#
# "Fit" additional models for K>2 & D==1 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K>2 & D==1){#
	# When D==1, all models are equivalent to one another (except fixed effects, which differs obviously)#
	if(is.null(tmpm2)){#
		messages[[length(messages)+1]] <- "Error: K>2, D==1 model error."#
		tmpv <- exp(mr.ea.equalvar.zerocorr$theta[1])^2#
		tmpf <- c(mr.ea.equalvar.zerocorr$theta[-1],0)#
		tmpf <- exp(tmpf)/sum(exp(tmpf))#
		tmpm2 <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", random=r.dv.k, sigma2=tmpv*tmpf)#
	}#
#
	if(!eammcs_only){#
		mr <- tmpm2#
		reml.ll[6,1] <- logLik(mr)#
		num.param[6,1] <- K#
	}#
#
	mr.ea <- mr.ea.equalvar.zerocorr#
	corr.ind <- numeric(0)#
	reml.ll[6,2] <- -mr.ea.equalvar.zerocorr$varcomp.opt$value#
	num.param[6,2] <- K	#
}#
if(K>2 & D>1){ mr <- mr.ea <- NULL } #
#incProgress(1/10)#
#
# Store log likelihood results#
results$K <- K+1#
results$D <- D#
results$REML.LL <- reml.ll#
results$Number.of.Variance.Component.Parameters <- num.param#
results$AIC <- 2*num.param - 2*reml.ll#
results$messages <- messages#
#
# Store estimates#
results$estimates <- list()#
if(!eammcs_only){ results$estimates$MMCS <- list() }#
results$estimates$EAMMCS <- list()#
tmpm <- mr.fe#
if(!eammcs_only){#
	results$estimates$MMCS$`Fixed Effects` <- list()#
	results$estimates$MMCS$`Fixed Effects`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Fixed Effects`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Fixed Effects`$vc  <- NA#
}#
tmpm <- mr.fe  # Equivalent to mr.ea.fe#
results$estimates$EAMMCS$`Fixed Effects` <- list()#
results$estimates$EAMMCS$`Fixed Effects`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Fixed Effects`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Fixed Effects`$vc  <- NA#
if(!eammcs_only){#
	tmpm <- mr.ea.equalvar.zerocorr  # Equivalent to mr.equalvar.zerocorr#
	tmpvc <- convert.theta.ea.equalvar.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Equal Var, Zero Corr` <- list()#
	results$estimates$MMCS$`Equal Var, Zero Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Equal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
	tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
	results$estimates$MMCS$`Equal Var, Zero Corr`$vc$variance  <- data.frame(tmpd)#
}#
tmpm <- mr.ea.equalvar.zerocorr#
tmpvc <- convert.theta.ea.equalvar.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
results$estimates$EAMMCS$`Equal Var, Zero Corr` <- list()#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$variance  <- tmpvc[[2]][1]#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.equalvar.onecorr#
	tmpvc <- convert.theta.equalvar.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Equal Var, Single Corr` <- list()#
	results$estimates$MMCS$`Equal Var, Single Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Equal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Equal Var, Single Corr`$vc$variance  <- apply(tmpvc[[1]], 3, function(x){x[1,1]})#
	if(D==1){#
		tmpcorr <- results$estimates$MMCS$`Equal Var, Single Corr`$vc$variance#
		tmpcorr[1:K] <- NA#
		results$estimates$MMCS$`Equal Var, Single Corr`$vc$correlation <- tmpcorr#
	}else{#
		results$estimates$MMCS$`Equal Var, Single Corr`$vc$correlation  <- apply(tmpvc[[1]], 3, function(x){cov2cor(x)[2,1]})#
	}		#
}#
tmpm <- mr.ea.equalvar.onecorr#
tmpvc <- convert.theta.ea.equalvar.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
tmpr <- ifelse(D==1, NA, unique(as.vector(tmpvc[[4]][ !is.na(tmpvc[[4]]) ])))#
results$estimates$EAMMCS$`Equal Var, Single Corr` <- list()#
results$estimates$EAMMCS$`Equal Var, Single Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$variance  <- tmpvc[[2]][1]#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$correlation  <- tmpr		#
tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.zerocorr#
	tmpvc <- convert.theta.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Unequal Var, Zero Corr` <- list()#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$vc$variance  <- apply(tmpvc[[1]], 3, diag)#
}#
tmpm <- mr.ea.zerocorr#
tmpvc <- convert.theta.ea.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
results$estimates$EAMMCS$`Unequal Var, Zero Corr` <- list()#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.onecorr#
	tmpvc <- convert.theta.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Unequal Var, Single Corr` <- list()#
	results$estimates$MMCS$`Unequal Var, Single Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Unequal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Unequal Var, Single Corr`$vc$variance  <- apply(tmpvc[[1]], 3, diag)#
	if(D==1){#
		tmpcorr <- results$estimates$MMCS$`Unequal Var, Single Corr`$vc$variance#
		tmpcorr[1:K] <- NA#
		results$estimates$MMCS$`Unequal Var, Single Corr`$vc$correlation <- tmpcorr#
	}else{#
		results$estimates$MMCS$`Unequal Var, Single Corr`$vc$correlation  <- apply(tmpvc[[1]], 3, function(x){cov2cor(x)[2,1]})#
	}#
}#
tmpm <- mr.ea.onecorr#
tmpvc <- convert.theta.ea.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
tmpr <- ifelse(D==1, NA, unique(as.vector(tmpvc[[4]][ !is.na(tmpvc[[4]]) ])))#
results$estimates$EAMMCS$`Unequal Var, Single Corr` <- list()#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$correlation  <- tmpr		#
tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	if(K<=2 && !is.null(mr)){#
		tmpm <- mr#
		results$estimates$MMCS$`No Constraints` <- list()#
		results$estimates$MMCS$`No Constraints`$fe.estimates  <-#
			data.frame( Estimate=as.vector(tmpm$b), SE=as.vector(tmpm$se), row.names=xx.col.names )#
		results$estimates$MMCS$`No Constraints`$fe.vcv  <- unname(tmpm$vb)#
		if(K==1){#
			tmpd <- matrix( tmpm$tau2, ncol=K, dimnames=list(udv,ulev) )#
		}else{#
			tmpd <- cbind( tmpm$tau2, tmpm$gamma2 )#
			dimnames(tmpd) <- list(udv, ulev)#
		}#
		results$estimates$MMCS$`No Constraints`$vc$variance  <- data.frame(tmpd)				#
		tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
		tmprr[upper.tri(tmprr)] <- tmpm$rho#
		tmprr <- tmprr + t(tmprr)#
		diag(tmprr) <- 1#
		if(K==1){#
			results$estimates$MMCS$`No Constraints`$vc[[2]]  <- data.frame(tmprr)#
		}else{#
			results$estimates$MMCS$`No Constraints`$vc[[2]]  <- data.frame(tmprr)					#
			tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
			tmprr[upper.tri(tmprr)] <- tmpm$phi#
			tmprr <- tmprr + t(tmprr)#
			diag(tmprr) <- 1#
			results$estimates$MMCS$`No Constraints`$vc[[3]]  <- data.frame(tmprr)					#
		}#
		names(results$estimates$MMCS$`No Constraints`$vc)[-1] <- paste0("correlation.",ulev)#
	}#
	if(K>2 && !is.null(mr)){#
		tmpm <- mr#
		results$estimates$MMCS$`No Constraints` <- list()#
		results$estimates$MMCS$`No Constraints`$fe.estimates  <-#
			data.frame( Estimate=as.vector(tmpm$b), SE=as.vector(tmpm$se), row.names=xx.col.names )#
		results$estimates$MMCS$`No Constraints`$fe.vcv  <- unname(tmpm$vb)#
		tmpd <- matrix( tmpm$sigma2, ncol=K, dimnames=list(udv,ulev) )#
		results$estimates$MMCS$`No Constraints`$vc$variance  <- data.frame(tmpd)#
		tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
		tmprr[upper.tri(tmprr)] <- tmpm$rho#
		tmprr <- tmprr + t(tmprr)#
		diag(tmprr) <- 1#
		for(i in 1:K){ results$estimates$MMCS$`No Constraints`$vc[[i+1]] <- data.frame(tmprr) }#
		names(results$estimates$MMCS$`No Constraints`$vc)[-1] <- paste0("correlation.", ulev)#
	}#
}#
if(!is.null(mr.ea)){#
	tmpm <- mr.ea#
	tmpvc <- convert.theta.ea.nc.custom( tmpm$theta, mv.ml.id, 1E-08, corr.ind )#
	results$estimates$EAMMCS$`No Constraints` <- list()#
	results$estimates$EAMMCS$`No Constraints`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$EAMMCS$`No Constraints`$fe.vcv  <- tmpm$covariance#
	results$estimates$EAMMCS$`No Constraints`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
	results$estimates$EAMMCS$`No Constraints`$vc$allocation  <-#
		data.frame( allocation=tmpvc[[3]], row.names=ulev )#
	tmprr <- tmpvc[[4]]#
	tmprr[upper.tri(tmprr,diag=TRUE)] <- 0#
	tmprr <- tmprr + t(tmprr)#
	diag(tmprr) <- 1#
	dimnames(tmprr) <- list(udv, udv)#
	results$estimates$EAMMCS$`No Constraints`$vc$correlation  <- data.frame(tmprr)#
	tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
	for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
	results$estimates$EAMMCS$`No Constraints`$vc$implied.variance <- data.frame(tmpd)#
	results$estimates$EAMMCS$`No Constraints`$vc$implied.vcv <- tmpvc[[1]]#
}			#
#
#incProgress(1/10)#
results#
#
date()
results[[5]]
results[[6]]
names(results)
results[[8]][[1]][[1]]
length(results[[8]])
results[[7]][[1]][[1]]
dat1 <- read.csv("case2.main.csv", header=TRUE)#
dat2 <- NULL#
eammcs_only <- FALSE#
# If no dat2: 		dat2 <- NULL#
#
dat1 <- dat1[,-7]#
library(metafor)#
source("aux.general.D.R")#
source("aux.reml.aux.blup.optim.option.R")#
results <- messages <- list()#
#
date()#
#
# Error checking I:#
if(is.null(dat1)){ return("Error: No main input data provided.") }#
if(any(is.na(dat1))){ return("Error: No NAs allowed in main input data.") }#
if(ncol(dat1) < 4){ return("Error: Main input data has less than four columns. It must have at minimum four columns.") }#
if(!is.null(dat2)){#
	if(any(is.na(dat2))){ return("Error: No NAs allowed in error variance covariance matrix.") }#
	if(nrow(dat1)!=nrow(dat2)){ return("Error: Main input data and error variance covariance matrix have a different number of rows.") }#
	if(nrow(dat2)!=ncol(dat2)){ return("Error: The error variance covariance matrix must be square.") }#
	Sigma.y <- as.matrix(dat2)#
	M <- max(abs( Sigma.y - t(Sigma.y) ))#
	if(M > 1E-08){ return("Error: The error variance covariance matrix must be symmetric.") }#
	m <- min(eigen(Sigma.y,only.values=TRUE)$values)#
	if(m < 1E-08){ return("Error: The error variance covariance matrix must be positive definite.") }#
	M <- max(abs( diag(Sigma.y) - dat1$v ))#
	if(M > 1E-08){ messages[[length(messages)+1]] <- paste0("Note: The diagonal of the error ",   #
		"variance covariance matrix and the v column of the main input data do not match. As always ",#
		"when an error variance covariance matrix is provided, using the error variance covariance ",#
		"matrix and ignoring the v column of the main input data.") }#
}else{#
	Sigma.y <- diag(dat1$v)#
}#
#
# Error checking II:#
idx1 <- which(colnames(dat1)=="ConditionDescription")#
idx2 <- which(colnames(dat1)=="DependentVariable")#
idx3 <- which(colnames(dat1)=="y")#
idx4 <- which(colnames(dat1)=="v")#
if(idx1!=1){ return("Error: First column of main input data must be ConditionDescription.") }#
if(idx2!=2){ return("Error: Second column of main input data must be DependentVariable.") }#
if(idx4!=(idx3+1)){ return("Error: Column v of main input data must immediately follow column y.") }#
if(!all( c(idx1,idx2,idx3,idx4)==sort(c(idx1,idx2,idx3,idx4)) )){#
	return("Error: Columns of main input data are not properly ordered.") }#
if(idx3==3){#
	messages[[length(messages)+1]] <- "Note: No levels entered. Using the observation as the sole hierarchical level."#
	dat1 <- data.frame( dat1[,1:2], ObsID=1:nrow(dat1), dat1[,-(1:2)] )#
	idx3 <- idx3+1#
	idx4 <- idx4+1#
}#
#
# Group Index Checking I: Checking for duplicate group ID variables#
mv.ml.id <- dat1[,idx2:(idx3-1),drop=FALSE]#
if(ncol(mv.ml.id) > 2){#
	drop.idx <- NULL#
	for(j1 in 3:ncol(mv.ml.id)){#
		for(j2 in 2:(j1-1)){#
			tmpt <- table(mv.ml.id[,j2], mv.ml.id[,j1])#
			tmpr <- rowSums(tmpt>0)#
			tmpc <- colSums(tmpt>0)#
			if(all(tmpr==1) & all(tmpc==1)){ #
				drop.idx <- c(drop.idx, j1)#
				tmpnj1 <- colnames(mv.ml.id)[j1]#
				tmpnj2 <- colnames(mv.ml.id)[j2]#
				messages[[length(messages)+1]] <-  #
					paste0("Note: The group ID variables ",	tmpnj2, " and ", tmpnj1,#
							" give identical groupings. Ignoring ", tmpnj1, ".")#
			}	#
		}#
	}#
	if(!is.null(drop.idx)){ mv.ml.id <- mv.ml.id[,-drop.idx,drop=FALSE] }#
}#
#
# Group Index Checking II: Checking for inner group index with values across #
# multiple outer group index values and giving a warning#
if(ncol(mv.ml.id) > 2){#
	for(i in 2:(ncol(mv.ml.id)-1)){#
		for(j in (i+1):ncol(mv.ml.id)){#
			tmpt <- table(mv.ml.id[,i], mv.ml.id[,j])#
			tmpc <- colSums(tmpt>0)#
			if(any(tmpc > 1)){#
				tmpni <- colnames(mv.ml.id)[i]#
				tmpnj <- colnames(mv.ml.id)[j]#
				messages[[length(messages)+1]] <-  #
					paste0("Note: One or more values of the inner group ID variable ", tmpnj,#
					" appears in more than one value of the outer group ID variable ", tmpni, ".")#
			}			#
		}#
	}#
}#
#
# Build variables#
y <- dat1$y#
dat1$DependentVariable <- as.factor(as.character(dat1$DependentVariable))#
dat1$ConditionDescription <- as.factor(as.character(dat1$ConditionDescription))#
for(i in 1:ncol(mv.ml.id)){ mv.ml.id[,i] <- as.factor(as.character(mv.ml.id[,i])) }#
dumb.vector <- rep(1,length(y))#
#
udv <- levels(dat1$DependentVariable)#
ucond <- levels(dat1$ConditionDescription)#
ulev <- colnames(mv.ml.id)[-1]#
D <- length(unique(mv.ml.id[,1]))		# Number of DVs#
K <- ncol(mv.ml.id) - 1					# Number of Hierarchical Levels (thus K in the code is one less than the K in the manuscript)#
#
# Build standard X matrix#
dv.cond <- as.factor(paste(dat1$DependentVariable, dat1$ConditionDescription, sep=" * "))#
u.dv.cond <- levels(dv.cond)#
X <- matrix(0, length(y), length(u.dv.cond))#
for(i in 1:length(u.dv.cond)){#
	sel <- dv.cond==u.dv.cond[i]#
	X[sel,i] <- 1#
}#
tmp <- which(colSums(X) > 0)#
X <- X[,tmp,drop=FALSE]#
xx.col.names <- u.dv.cond[tmp]#
#
# Add covariates to X#
X1 <- X#
if(ncol(dat1) > idx4){#
	covariate.matrix <- as.matrix( dat1[,(idx4+1):ncol(dat1),drop=FALSE] )#
	for(i in 1:ncol(covariate.matrix)){#
		tmpX <- X * covariate.matrix[,i]#
		tmp <- which(apply(tmpX, 2, sd) > 0)  #
		tmpX <- tmpX[,tmp]#
		X <- cbind(X, tmpX)#
		xx.col.names <- c(xx.col.names, paste(xx.col.names[tmp], colnames(covariate.matrix)[i], sep=" * "))#
	}#
}#
if(ncol(X) > nrow(X)){ return("Error: There are more covariates than rows of data. Reduce the number of covariates.") }#
#
# Set up model evaluation matrices#
reml.ll <- num.param <- matrix(NA, 6, 2)#
colnames(reml.ll) <- colnames(num.param) <- c("MMCS", "EAMMCS")#
rownames(reml.ll) <- rownames(num.param) <- #
	c("Fixed Effects", "Equal Var, Zero Corr", "Equal Var, Single Corr", "Unequal Var, Zero Corr", "Unequal Var, Single Corr", "No Constraints")#
num.param[1,] <- c(0,0)#
num.param[2,] <- c(K,K)#
num.param[3,1] <- K + K*(D>1)#
num.param[3,2] <- K + 1*(D>1)#
num.param[4,1] <- D*K#
num.param[4,2] <- D+K-1#
num.param[5,1] <- D*K + K*(D>1)#
num.param[5,2] <- D+K-1 + 1*(D>1)#
if(eammcs_only){ num.param[,1] <- NA }#
#
# Set up metafor random effects calls#
r.dv.k <- r.k <- list(NULL)#
for(i in 2:ncol(mv.ml.id)){#
	tmps <- paste("~1 | paste(mv.ml.id[, 1], mv.ml.id[, ", i, "], sep = ' - ')", sep="")#
	r.dv.k[[i-1]] <- as.formula(tmps)#
	tmps <- paste("~1 | mv.ml.id[sel, ", i, "]", sep="")#
	r.k[[i-1]] <- as.formula(tmps)#
}#
#
# Fit EAMMCS Fixed Effect Model#
mr.fe <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz.fe, R=Sigma.y, blup=FALSE, eval=TRUE, theta.init=NA)#
#incProgress(0.5/10)#
#
# Fit EAMMCS Equal Variance, Zero Correlation Model#
system.time({ #
tmpm1 <- tmpm2 <- NULL#
try( tmpm1 <- rma.uni(y, diag(Sigma.y), mods=~X-1) )#
try( tmpm2 <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", random=r.dv.k, control=list(maxit=10000)) )#
tmp.init <- rep(0,K)#
if(!is.null(tmpm1)){ tmp.init <- c( log(sqrt( max(tmpm1$tau2,1E-04) )), rep(0,K-1) ) }#
if(!is.null(tmpm2)){#
	if(K==1){ tmp.init <- log(sqrt( max(sum(tmpm2$sigma2),1E-08) ))#
	}else{#
		tmp.init0 <- log(sqrt( max(sum(tmpm2$sigma2),1E-08) ))#
		tmp.init1 <- log(tmpm2$sigma2[1:(K-1)]/tmpm2$sigma2[K])#
		tmp.init1[tmp.init1==Inf] <- 10#
		tmp.init <- c(tmp.init0, tmp.init1)#
	}#
	mr.ea.equalvar.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)	#
}else{#
	mr.ea.equalvar.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.zerocorr, blup=FALSE, eps=1E-08)	#
}#
})#
#incProgress(0.5/10)#
#
# Fit EAMMCS Equal Variance, Single Correlation Model#
if(D==1){ #
	tmp.init <- c(mr.ea.equalvar.zerocorr$theta[1], NA, mr.ea.equalvar.zerocorr$theta[-1])#
	mr.ea.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmp.init <- c( mr.ea.equalvar.zerocorr$theta[1], -3, mr.ea.equalvar.zerocorr$theta[-1] )#
	mr.ea.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.equalvar.onecorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Fit EAMMCS Unequal Variance, Zero Correlation Model#
if(D==1){ #
	tmp.init <- mr.ea.equalvar.zerocorr$theta#
	mr.ea.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmpm1 <- tmpm2 <- list(NULL)#
	tmp.init <- c( rep(mr.ea.equalvar.zerocorr$theta[1], D), mr.ea.equalvar.zerocorr$theta[-1] )#
	for(i in 1:length(udv)){#
		tmpm1[[i]] <- tmpm2[[i]] <- NA#
		sel <- mv.ml.id[,1]==udv[i]#
		try( tmpm1[[i]] <- rma.uni(y[sel], diag(Sigma.y)[sel], mods=~X[sel,]-1) )#
		try( tmpm2[[i]] <- rma.mv(y[sel], Sigma.y[sel,sel], mods=~X[sel,]-1, struct="CS", random=r.k, control=list(maxit=10000)) )#
		if(!is.na(tmpm1[[i]])){ tmp.init[i] <- log(sqrt( max(tmpm1[[i]]$tau2,1E-04) )) }#
		if(!is.na(tmpm2[[i]])){ tmp.init[i] <- log(sqrt( max(sum(tmpm2[[i]]$sigma2),1E-04) )) }#
	}#
	mr.ea.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.zerocorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Fit EAMMCS Unequal Variance, Single Correlation Model#
if(D==1){ #
	tmp.init <- c(mr.ea.zerocorr$theta[1], NA, mr.ea.zerocorr$theta[-1])#
	mr.ea.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
}else{#
system.time({#
	tmp.init <- c( mr.ea.zerocorr$theta[1:D], -3, mr.ea.zerocorr$theta[-(1:D)] )#
	mr.ea.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
		R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.onecorr, blup=FALSE, eps=1E-08)#
})}#
#incProgress(1/10)#
#
# Save results of EAMMCS models#
reml.ll[1,] <- -mr.fe$varcomp.opt$value#
reml.ll[2,] <- -min(tryCatch(mr.ea.equalvar.zerocorr$varcomp.opt$value), tryCatch(mr.ea.equalvar.zerocorr$varcomp.opt$objective))#
reml.ll[3,2] <- -mr.ea.equalvar.onecorr$varcomp.opt$value#
reml.ll[4,2] <-  -min(tryCatch(mr.ea.zerocorr$varcomp.opt$value), tryCatch(mr.ea.zerocorr$varcomp.opt$objective))#
reml.ll[5,2] <- -mr.ea.onecorr$varcomp.opt$value#
if(eammcs_only){ reml.ll[1:2,1] <- NA }#
#
if(!eammcs_only){#
	# Fit MMCS Equal Variance, Single Correlation Model#
	# We force positive correlations even though for K==1 and K==2 we can use metafor to get negative#
	# correlations. Nonetheless, we provide a message noting when a negative correlaion improves fit.#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- c(log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] )))#
		mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.equalvar.onecorr.rma.mv <- mr.equalvar.onecorr <- NULL#
			try( mr.equalvar.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2])) )#
			tmp.init <- mr.ea.equalvar.onecorr$theta#
			mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho>0){#
				if( abs(reml.ll[3,1] - logLik(mr.equalvar.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Equal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho<=0){#
				messages[[length(messages)+1]] <- paste0("K=2 MMCS Equal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML LL improves from ", reml.ll[3,1],#
					" to ", logLik(mr.equalvar.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.equalvar.onecorr.rma.mv <- mr.equalvar.onecorr <- NULL#
			try( mr.equalvar.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && mr.equalvar.onecorr.rma.mv$rho>0 && mr.equalvar.onecorr.rma.mv$phi>0){ #
				tmp.init <- c(log(sqrt(mr.equalvar.onecorr.rma.mv$tau2)),#
							  log(sqrt(mr.equalvar.onecorr.rma.mv$gamma2)),#
							  logit(mr.equalvar.onecorr.rma.mv$rho),#
							  logit(mr.equalvar.onecorr.rma.mv$phi))#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.equalvar.onecorr.rma.mv) || mr.equalvar.onecorr.rma.mv$rho<=0 || mr.equalvar.onecorr.rma.mv$phi<=0){#
				tmp.init.convert <- convert.theta.ea.equalvar.onecorr(mr.ea.equalvar.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt(tmp.init.convert[[2]][1]*tmp.init.convert[[3]])),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.equalvar.onecorr)){#
				reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && mr.equalvar.onecorr.rma.mv$rho>0 && mr.equalvar.onecorr.rma.mv$phi>0){#
				if( abs(reml.ll[3,1] - logLik(mr.equalvar.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Equal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.equalvar.onecorr.rma.mv) && !is.null(mr.equalvar.onecorr) && (mr.equalvar.onecorr.rma.mv$rho<=0 || mr.equalvar.onecorr.rma.mv$phi<=0)){#
				messages[[length(messages)+1]] <- paste0("K=3 MMCS Equal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML  LL improves from ", reml.ll[3,1],#
					" to ", logLik(mr.equalvar.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.equalvar.onecorr(mr.ea.equalvar.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt(tmp.init.convert[[2]][1]*tmp.init.convert[[3]])),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.equalvar.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.equalvar.onecorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.equalvar.onecorr)){#
					reml.ll[3,1] <- -min(tryCatch(mr.equalvar.onecorr$varcomp.opt$value), tryCatch(mr.equalvar.onecorr$varcomp.opt$objective))#
				}#
			})#
		}#
	}#
	#incProgress(1.5/10)#
#
	# Fit MMCS Unequal Variance, Zero Correlation Model#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] ))#
		mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# Confirm equivalence of all three#
			mr.zerocorr.rma.mv <- mr.zerocorr <- NULL#
			try( mr.zerocorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2]), rho=0) )#
			tmp.init <- mr.ea.zerocorr$theta#
			mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
			if(!is.null(mr.zerocorr.rma.mv)){#
				if( abs(reml.ll[4,1] - logLik(mr.zerocorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Unequal Variance, Zero Correlation Error." }#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# Confirm equivalence to metafor#
			mr.zerocorr.rma.mv <- mr.zerocorr <- NULL#
			try( mr.zerocorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3]), rho=0, phi=0) )#
			if(!is.null(mr.zerocorr.rma.mv)){ #
				tmp.init <- log(sqrt(as.vector( t(matrix(c(mr.zerocorr.rma.mv$tau2, mr.zerocorr.rma.mv$gamma2), D, K)) )))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.zerocorr.rma.mv)){#
				tmp.init.convert <- convert.theta.ea.zerocorr(mr.ea.zerocorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- log(sqrt( as.vector(t(outer(tmp.init.convert[[2]], tmp.init.convert[[3]]))) ))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.zerocorr)){#
				reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.zerocorr.rma.mv) & !is.null(mr.zerocorr)){#
				if( abs(reml.ll[4,1] - logLik(mr.zerocorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Unequal Variance, Zero Correlation Error." }#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.zerocorr(mr.ea.zerocorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- log(sqrt( as.vector(t(outer(tmp.init.convert[[2]], tmp.init.convert[[3]]))) ))#
				mr.zerocorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.zerocorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.zerocorr)){#
					reml.ll[4,1] <- -min(tryCatch(mr.zerocorr$varcomp.opt$value), tryCatch(mr.zerocorr$varcomp.opt$objective))#
				}#
			})#
		}	#
	}#
	#incProgress(1/10)#
#
	# Fit MMCS Unequal Variance, Single Correlation Model#
	# We force positive correlations even though for K==1 and K==2 we can use metafor to get negative#
	# correlations. Nonetheless, we provide a message noting when a negative correlaion improves fit.#
	if(D==1){ #
		tmp.init.convert <- convert.theta.ea.equalvar.zerocorr(mr.ea.equalvar.zerocorr$theta, mv.ml.id, 1E-08)#
		tmp.init <- c(log(sqrt( tmp.init.convert[[2]]*tmp.init.convert[[3]] )))#
		mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)#
		reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
	}else{#
		if(K==1){#
			system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# Confirm equivalence of all three#
			mr.onecorr.rma.mv <- mr.onecorr <- NULL#
			try( mr.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2])) )#
			tmp.init <- mr.ea.onecorr$theta#
			mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
				R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eval=TRUE, eps=1E-08)		#
			reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho>0){#
				if( abs(reml.ll[5,1] - logLik(mr.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=2 MMCS Unequal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho<=0){#
				messages[[length(messages)+1]] <- paste0("K=2 MMCS Unequal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML LL improves from ", reml.ll[5,1],#
					" to ", logLik(mr.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K==2){#
			system.time({#
			# metafor allows negative correlations while we force positive correlations so we will fit both#
			# Confirm equivalence of all three if metafor correlation is positive#
			mr.onecorr.rma.mv <- mr.onecorr <- NULL#
			try( mr.onecorr.rma.mv <- rma.mv(y, Sigma.y, mods=~X-1, struct="HCS", control=list(maxit=10000),#
									random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
			if(!is.null(mr.onecorr.rma.mv) && mr.onecorr.rma.mv$rho>0 && mr.onecorr.rma.mv$phi>0){ #
				tmp.init <- c(log(sqrt(mr.onecorr.rma.mv$tau2)),#
							  log(sqrt(mr.onecorr.rma.mv$gamma2)),#
							  logit(mr.onecorr.rma.mv$rho),#
							  logit(mr.onecorr.rma.mv$phi))#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(is.null(mr.onecorr.rma.mv) || mr.onecorr.rma.mv$rho<=0 || mr.onecorr.rma.mv$phi<=0){#
				tmp.init.convert <- convert.theta.ea.onecorr(mr.ea.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt( as.vector(outer(tmp.init.convert[[2]], tmp.init.convert[[3]])) )),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
			}#
			if(!is.null(mr.onecorr)){#
				reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && mr.onecorr.rma.mv$rho>0 && mr.onecorr.rma.mv$phi>0){#
				if( abs(reml.ll[5,1] - logLik(mr.onecorr.rma.mv)) > 1E-04 ){ #
					messages[[length(messages)+1]] <- "Error: K=3 MMCS Unequal Variance, Single Correlation Error." }#
			}#
			if(!is.null(mr.onecorr.rma.mv) && !is.null(mr.onecorr) && (mr.onecorr.rma.mv$rho<=0 || mr.onecorr.rma.mv$phi<=0)){#
				messages[[length(messages)+1]] <- paste0("K=3 MMCS Unequal Variance, Single Correlation results ",#
				 	"can be improved by allowing negative correlations. The REML  LL improves from ", reml.ll[5,1],#
					" to ", logLik(mr.onecorr.rma.mv), ".")#
			}#
			})#
		}#
#
		if(K>2){#
			system.time({#
				tmp.init.convert <- convert.theta.ea.onecorr(mr.ea.onecorr$theta, mv.ml.id, 1E-08)#
				tmp.init <- c( log(sqrt( as.vector(outer(tmp.init.convert[[2]], tmp.init.convert[[3]])) )),#
							   rep(logit(tmp.init.convert[[4]][2,1]), K) )#
				mr.onecorr <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
					R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.onecorr, blup=FALSE, eps=1E-08)#
				if(!is.null(mr.onecorr)){#
					reml.ll[5,1] <- -min(tryCatch(mr.onecorr$varcomp.opt$value), tryCatch(mr.onecorr$varcomp.opt$objective))#
				}#
			})#
		}#
	}#
	#incProgress(1.5/10)#
}else{#
	#incProgress(4/10)#
}#
#
# Fit additional models for K==1 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K==1){#
	system.time({#
			# W/ K=1, MMCS & EAMMCS are equivalent bc all allocations are 100% to the sole hierarchical level#
			# However, with No Constraints metafor allows negative correlations while we force positive#
			# correlations so we will fit both#
#
			# MMCS No Constraint#
			mr <- NULL#
			try( mr <- rma.mv(y, Sigma.y, mods=~X-1, struct="UN", control=list(maxit=10000),#
										random=~mv.ml.id[,1]|mv.ml.id[,2]) )#
			if(!is.null(mr) & !eammcs_only){ #
				num.param[6,1] <- sum( unlist(mr$vc.fix)==FALSE, na.rm=TRUE )#
				reml.ll[6,1] <- logLik(mr)#
			}#
	})#
#
	# EAMMCS No Constraint - If all MMCS No Constraint correlations are positive this is #
	# the same model so we will simply evaluate (rather than maximize it) using our code.#
	# But, if all MMCS No Constraint correlations are NOT positive this is we must maximize#
	# using our code#
	mr.ea <- NULL#
	if(D==1){ mr.ea <- mr.ea.equalvar.zerocorr; corr.ind <- numeric(0) }#
	system.time({ if(D!=1 & !is.null(mr) & all(mr$rho >= 0)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- logit(pmin(pmax(mr$rho,1E-08),1-1E-08))#
		tmp <- upper.tri.vec.to.lower.tri.vec(tmp)[corr.ind==1]#
		tmp.init <- c(log(sqrt( pmax(mr$tau2,1E-08) )), tmp)#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eval=TRUE, eps=1E-08) )#
		if(!is.null(mr.ea)){#
			if(abs(-mr.ea$varcomp.opt$value - logLik(mr)) > 1E-04){ #
				messages[[length(messages)+1]] <- "Error: K=2 EAMMCS No Constraint Error." }#
		}	#
	} })#
	system.time({ if(D!=1 & !is.null(mr) & !all(mr$rho >= 0)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- mr.ea.onecorr$theta[D+1]#
		tmp.init <- c(mr.ea.onecorr$theta[1:D], rep(tmp,sum(corr.ind)), mr.ea.onecorr$theta[-(1:(D+1))])#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eps=1E-08) )#
	} })#
	if(!is.null(mr.ea)){#
		num.param[6,2] <- length(mr.ea$theta)#
		reml.ll[6,2] <- -mr.ea$varcomp.opt$value#
	}	#
}#
#
# Fit additional models for K==2 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K==2){#
	system.time({#
		# MMCS No Constraint#
		mr <- NULL#
		try( mr <- rma.mv(y, Sigma.y, mods=~X-1, struct="UN", control=list(maxit=10000),#
								random=list(~mv.ml.id[,1]|mv.ml.id[,2],~mv.ml.id[,1]|mv.ml.id[,3])) )#
		if(!is.null(mr) & !eammcs_only){ #
			num.param[6,1] <- sum( unlist(mr$vc.fix)==FALSE, na.rm=TRUE ) #
			reml.ll[6,1] <- logLik(mr)#
		}#
	})#
#
	# EAMMCS No Constraint#
	mr.ea <- NULL#
	if(D==1){ mr.ea <- mr.ea.equalvar.zerocorr; corr.ind <- numeric(0)#
	}else{	#
	system.time({ if(!is.null(mr)){#
		# Get indicator of identified correlations and then flip to lower triangular version#
		tmp <- 1*(mr$vc.fix$rho==FALSE | mr$vc.fix$phi==FALSE)	#
		corr.ind <- upper.tri.vec.to.lower.tri.vec(tmp)#
#
		# Get inits and fit model#
		tmp <- mr.ea.onecorr$theta[D+1]#
		tmp.init <- c(mr.ea.onecorr$theta[1:D], rep(tmp,sum(corr.ind)), mr.ea.onecorr$theta[-(1:(D+1))])#
		mr.ea <- NULL#
		try( mr.ea <- my.reml(y, dumb.vector, X, var.fcn=overload.zdz, theta.init=tmp.init,#
			R=Sigma.y, mv.ml.id=mv.ml.id, convert.fcn=convert.theta.ea.nc.custom, #
			corr.ind=corr.ind, blup=FALSE, eval=(D==2), eps=1E-08) )#
	}})}#
	if(!is.null(mr.ea)){#
		num.param[6,2] <- length(mr.ea$theta)#
		reml.ll[6,2] <- -mr.ea$varcomp.opt$value#
	}#
}#
#
# "Fit" additional models for K>2 & D==1 (i.e., NoConstraint,MMCS;  NoConstraint,EAMMCS)#
if(K>2 & D==1){#
	# When D==1, all models are equivalent to one another (except fixed effects, which differs obviously)#
	if(is.null(tmpm2)){#
		messages[[length(messages)+1]] <- "Error: K>2, D==1 model error."#
		tmpv <- exp(mr.ea.equalvar.zerocorr$theta[1])^2#
		tmpf <- c(mr.ea.equalvar.zerocorr$theta[-1],0)#
		tmpf <- exp(tmpf)/sum(exp(tmpf))#
		tmpm2 <- rma.mv(y, Sigma.y, mods=~X-1, struct="CS", random=r.dv.k, sigma2=tmpv*tmpf)#
	}#
#
	if(!eammcs_only){#
		mr <- tmpm2#
		reml.ll[6,1] <- logLik(mr)#
		num.param[6,1] <- K#
	}#
#
	mr.ea <- mr.ea.equalvar.zerocorr#
	corr.ind <- numeric(0)#
	reml.ll[6,2] <- -mr.ea.equalvar.zerocorr$varcomp.opt$value#
	num.param[6,2] <- K	#
}#
if(K>2 & D>1){ mr <- mr.ea <- NULL } #
#incProgress(1/10)#
#
# Store log likelihood results#
results$K <- K+1#
results$D <- D#
results$REML.LL <- reml.ll#
results$Number.of.Variance.Component.Parameters <- num.param#
results$AIC <- 2*num.param - 2*reml.ll#
results$messages <- messages#
#
# Store estimates#
results$estimates <- list()#
if(!eammcs_only){ results$estimates$MMCS <- list() }#
results$estimates$EAMMCS <- list()#
tmpm <- mr.fe#
if(!eammcs_only){#
	results$estimates$MMCS$`Fixed Effects` <- list()#
	results$estimates$MMCS$`Fixed Effects`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Fixed Effects`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Fixed Effects`$vc  <- NA#
}#
tmpm <- mr.fe  # Equivalent to mr.ea.fe#
results$estimates$EAMMCS$`Fixed Effects` <- list()#
results$estimates$EAMMCS$`Fixed Effects`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Fixed Effects`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Fixed Effects`$vc  <- NA#
if(!eammcs_only){#
	tmpm <- mr.ea.equalvar.zerocorr  # Equivalent to mr.equalvar.zerocorr#
	tmpvc <- convert.theta.ea.equalvar.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Equal Var, Zero Corr` <- list()#
	results$estimates$MMCS$`Equal Var, Zero Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Equal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
	tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
	results$estimates$MMCS$`Equal Var, Zero Corr`$vc$variance  <- data.frame(tmpd)#
}#
tmpm <- mr.ea.equalvar.zerocorr#
tmpvc <- convert.theta.ea.equalvar.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
results$estimates$EAMMCS$`Equal Var, Zero Corr` <- list()#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$variance  <- tmpvc[[2]][1]#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Equal Var, Zero Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.equalvar.onecorr#
	tmpvc <- convert.theta.equalvar.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Equal Var, Single Corr` <- list()#
	results$estimates$MMCS$`Equal Var, Single Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Equal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Equal Var, Single Corr`$vc$variance  <- apply(tmpvc[[1]], 3, function(x){x[1,1]})#
	if(D==1){#
		tmpcorr <- results$estimates$MMCS$`Equal Var, Single Corr`$vc$variance#
		tmpcorr[1:K] <- NA#
		results$estimates$MMCS$`Equal Var, Single Corr`$vc$correlation <- tmpcorr#
	}else{#
		results$estimates$MMCS$`Equal Var, Single Corr`$vc$correlation  <- apply(tmpvc[[1]], 3, function(x){cov2cor(x)[2,1]})#
	}		#
}#
tmpm <- mr.ea.equalvar.onecorr#
tmpvc <- convert.theta.ea.equalvar.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
tmpr <- ifelse(D==1, NA, unique(as.vector(tmpvc[[4]][ !is.na(tmpvc[[4]]) ])))#
results$estimates$EAMMCS$`Equal Var, Single Corr` <- list()#
results$estimates$EAMMCS$`Equal Var, Single Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$variance  <- tmpvc[[2]][1]#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$correlation  <- tmpr		#
tmpd <- matrix( tmpvc[[2]][1]*tmpvc[[3]], ncol=K, dimnames=list(NULL,ulev) )#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Equal Var, Single Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.zerocorr#
	tmpvc <- convert.theta.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Unequal Var, Zero Corr` <- list()#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Unequal Var, Zero Corr`$vc$variance  <- apply(tmpvc[[1]], 3, diag)#
}#
tmpm <- mr.ea.zerocorr#
tmpvc <- convert.theta.ea.zerocorr( tmpm$theta, mv.ml.id, 1E-08 )#
results$estimates$EAMMCS$`Unequal Var, Zero Corr` <- list()#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Unequal Var, Zero Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	tmpm <- mr.onecorr#
	tmpvc <- convert.theta.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
	results$estimates$MMCS$`Unequal Var, Single Corr` <- list()#
	results$estimates$MMCS$`Unequal Var, Single Corr`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$MMCS$`Unequal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
	results$estimates$MMCS$`Unequal Var, Single Corr`$vc$variance  <- apply(tmpvc[[1]], 3, diag)#
	if(D==1){#
		tmpcorr <- results$estimates$MMCS$`Unequal Var, Single Corr`$vc$variance#
		tmpcorr[1:K] <- NA#
		results$estimates$MMCS$`Unequal Var, Single Corr`$vc$correlation <- tmpcorr#
	}else{#
		results$estimates$MMCS$`Unequal Var, Single Corr`$vc$correlation  <- apply(tmpvc[[1]], 3, function(x){cov2cor(x)[2,1]})#
	}#
}#
tmpm <- mr.ea.onecorr#
tmpvc <- convert.theta.ea.onecorr( tmpm$theta, mv.ml.id, 1E-08 )#
tmpr <- ifelse(D==1, NA, unique(as.vector(tmpvc[[4]][ !is.na(tmpvc[[4]]) ])))#
results$estimates$EAMMCS$`Unequal Var, Single Corr` <- list()#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$fe.estimates  <-#
	data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$fe.vcv  <- tmpm$covariance#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$allocation  <-#
	data.frame( allocation=tmpvc[[3]], row.names=ulev )#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$correlation  <- tmpr		#
tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$implied.variance <- data.frame(tmpd)#
results$estimates$EAMMCS$`Unequal Var, Single Corr`$vc$implied.vcv <- tmpvc[[1]]#
if(!eammcs_only){#
	if(K<=2 && !is.null(mr)){#
		tmpm <- mr#
		results$estimates$MMCS$`No Constraints` <- list()#
		results$estimates$MMCS$`No Constraints`$fe.estimates  <-#
			data.frame( Estimate=as.vector(tmpm$b), SE=as.vector(tmpm$se), row.names=xx.col.names )#
		results$estimates$MMCS$`No Constraints`$fe.vcv  <- unname(tmpm$vb)#
		if(K==1){#
			tmpd <- matrix( tmpm$tau2, ncol=K, dimnames=list(udv,ulev) )#
		}else{#
			tmpd <- cbind( tmpm$tau2, tmpm$gamma2 )#
			dimnames(tmpd) <- list(udv, ulev)#
		}#
		results$estimates$MMCS$`No Constraints`$vc$variance  <- data.frame(tmpd)				#
		tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
		tmprr[upper.tri(tmprr)] <- tmpm$rho#
		tmprr <- tmprr + t(tmprr)#
		diag(tmprr) <- 1#
		if(K==1){#
			results$estimates$MMCS$`No Constraints`$vc[[2]]  <- data.frame(tmprr)#
		}else{#
			results$estimates$MMCS$`No Constraints`$vc[[2]]  <- data.frame(tmprr)					#
			tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
			tmprr[upper.tri(tmprr)] <- tmpm$phi#
			tmprr <- tmprr + t(tmprr)#
			diag(tmprr) <- 1#
			results$estimates$MMCS$`No Constraints`$vc[[3]]  <- data.frame(tmprr)					#
		}#
		names(results$estimates$MMCS$`No Constraints`$vc)[-1] <- paste0("correlation.",ulev)#
	}#
	if(K>2 && !is.null(mr)){#
		tmpm <- mr#
		results$estimates$MMCS$`No Constraints` <- list()#
		results$estimates$MMCS$`No Constraints`$fe.estimates  <-#
			data.frame( Estimate=as.vector(tmpm$b), SE=as.vector(tmpm$se), row.names=xx.col.names )#
		results$estimates$MMCS$`No Constraints`$fe.vcv  <- unname(tmpm$vb)#
		tmpd <- matrix( tmpm$sigma2, ncol=K, dimnames=list(udv,ulev) )#
		results$estimates$MMCS$`No Constraints`$vc$variance  <- data.frame(tmpd)#
		tmprr <- matrix(0,D,D,dimnames=list(udv,udv))#
		tmprr[upper.tri(tmprr)] <- tmpm$rho#
		tmprr <- tmprr + t(tmprr)#
		diag(tmprr) <- 1#
		for(i in 1:K){ results$estimates$MMCS$`No Constraints`$vc[[i+1]] <- data.frame(tmprr) }#
		names(results$estimates$MMCS$`No Constraints`$vc)[-1] <- paste0("correlation.", ulev)#
	}#
}#
if(!is.null(mr.ea)){#
	tmpm <- mr.ea#
	tmpvc <- convert.theta.ea.nc.custom( tmpm$theta, mv.ml.id, 1E-08, corr.ind )#
	results$estimates$EAMMCS$`No Constraints` <- list()#
	results$estimates$EAMMCS$`No Constraints`$fe.estimates  <-#
		data.frame( Estimate=tmpm$alpha, SE=sqrt(diag(tmpm$covariance)), row.names=xx.col.names )#
	results$estimates$EAMMCS$`No Constraints`$fe.vcv  <- tmpm$covariance#
	results$estimates$EAMMCS$`No Constraints`$vc$variance  <- data.frame(variance=tmpvc[[2]], row.names=udv)#
	results$estimates$EAMMCS$`No Constraints`$vc$allocation  <-#
		data.frame( allocation=tmpvc[[3]], row.names=ulev )#
	tmprr <- tmpvc[[4]]#
	tmprr[upper.tri(tmprr,diag=TRUE)] <- 0#
	tmprr <- tmprr + t(tmprr)#
	diag(tmprr) <- 1#
	dimnames(tmprr) <- list(udv, udv)#
	results$estimates$EAMMCS$`No Constraints`$vc$correlation  <- data.frame(tmprr)#
	tmpd <- matrix(NA,D,K,dimnames=list(udv,ulev))#
	for(i in 1:D){ tmpd[i,] <- tmpvc[[2]][i] * tmpvc[[3]] }#
	results$estimates$EAMMCS$`No Constraints`$vc$implied.variance <- data.frame(tmpd)#
	results$estimates$EAMMCS$`No Constraints`$vc$implied.vcv <- tmpvc[[1]]#
}			#
#
#incProgress(1/10)#
results#
#
date()
results[[7]][[1]][[1]]
length(results[[7]][[1]])
results[[7]][[1]][[6]]
results[[5]]
results[[3]]
K>2 & D==1
K>2 & D>1
K
D
results$K
results$D
results[[5]]
library(foreign)#
dat <- data.frame(read.spss("/Users/blakemcshane/Dropbox/Dropbox Research/Blake_Ulf/PowerCalculations/Analysis/uncertainty_and_heterogeneity/manylabs/Data/CleanedDataset.sav"))
library(foreign)#
dat2 <- data.frame(read.spss("/Users/blakemcshane/Desktop/Data/CleanedDataset.sav"))
dim(dat)
dim(dat2)
t(colnames(dat2))
t(t(colnames(dat2)))
library(devtools)
install.packages("usethis")
library(devtools)
~/Library/Containers/com.apple.mail/Data/Library/Mail Downloads/5230364F-D04E-4CC2-821B-9F0EF625B1F9/results.Rdata
load('~/Desktop/results.Rdata')
results[[5]]
results[[7]][[2]][[6]]
results[[7]][[2]][[5]]
library(kelloggmktg482)
library(mktg482)
devtools::install_github("blakemcshane/kelloggmktg482")
devtools::install_github("blakemcshane/kelloggmktg482", upgrade="never", force=TRUE)
devtools::install_github("blakemcshane/kelloggmktg482")
load('~/Desktop/results_wo_behavior.Rdata')
results[[5]]
results$k
results$K
results$D
names(results)
results[[3]]
results[[4]]
results[[5]]
min(results[[5]], na.rm=TRUE)
results$K
results$D
dat1 <- read.csv("mydata-02.25.22.csv", header=TRUE)
dim(dat1)
dat1[dat1$DependentVariable=="Behavioral",]
dat1[dat1$DependentVariable=="Behavior",]
load('~/Desktop/gizem/results.Rdata')
results[[3]]
results[[5]]
load('~/Desktop/gizem/results_wo_behavior.Rdata')
results[[5]]
load('~/Desktop/gizem/results.Rdata')
results[[3]]
load('~/Desktop/gizem/results_wo_behavior.Rdata')
results[[3]]
library(devtools)
devtools::install_github("blakemcshane/kelloggmktg482")
library(devtools)
devtools::install_github("blakemcshane/kelloggmktg482")
library(kelloggmktg482)
gainsplot
ss.2proportion
varimpplot
library(devtools)
?install_github
devtools::install_github("blakemcshane/kelloggmktg482", upgrade = "never", force = TRUE)
library(kelloggmktg482)
devtools::install_github("blakemcshane/kelloggmktg482", upgrade = "never", force = TRUE)
library(kelloggmktg482)
library(devtools)#
setwd("/Users/blakemcshane/Repositories")#
#
devtools::create("kelloggmktg482")
devtools::document("kelloggmktg482")
devtools::document("kelloggmktg482")
devtools::document("kelloggmktg482")
